================================================================================
THE CHRONICLE OF CK3 COAT OF ARMS EDITOR - A HISTORICAL ANALYSIS
================================================================================
A Deep Archaeological Study of Technical Decisions, Evolution, and Patterns
Document Date: January 29, 2026
Total Commits Analyzed: 174
Project Lifespan: ~1 week of intensive development
================================================================================

EXECUTIVE SUMMARY
================================================================================

This document tells the story of how a seemingly simple layer editing system
evolved into a complex coordinate transformation pipeline, and why certain
"obvious" bugs exist in the current codebase. Through git archaeology, we
uncover the reasoning behind design decisions and identify patterns that
explain today's integration challenges.

KEY INSIGHTS:
1. The transform system has undergone 3 major architectural rewrites
2. Coordinate system bugs plagued development for ~40% of commits
3. Multi-selection was bolt-on architecture, not original design
4. The AABB caching system emerged from 8+ bug fixes over 3 days
5. Current instancing bug is architecturally predicted by history

================================================================================
PART I: THE GENESIS - BIRTH OF THE RENDERING PIPELINE
================================================================================

1.1 THE FIRST ARCHITECTURE (Pre-RTT Era)
-----------------------------------------
Commit: bc815fb (Jan 23, 2026)
"Add interactive transform widget for layer manipulation"

Initial System Design:
- Direct OpenGL rendering (single-pass)
- Simple layer structure: layer['pos_x'], layer['pos_x'], etc.
- Transform widget overlaid on canvas
- 1:1 coordinate mapping (no zoom complexity)

Architecture Philosophy:
> "Widget overlays on canvas with absolute positioning"
> "Matches canvas coordinate system for accurate layer alignment"

OBSERVATION: The original design was SIMPLE. Single-pass rendering,
direct property access, no coordinate conversion functions. The widget
"just worked" because there was no complexity to fight.

CRITICAL INSIGHT: Layer data was ALWAYS accessed directly as layer['pos_x'].
This pattern was established on Day 1 and became muscle memory for the developer.


1.2 THE GREAT REFACTOR - RTT RENDERING ARRIVES
-----------------------------------------------
Commit: 8e7a364 (Jan 27, 2026)
"Implement two-pass RTT rendering (MAJOR REFACTOR)"

WHY THIS CHANGE?
The commit message reveals the motivation:
> "✅ Removed 1.1x position scaling"
> "✅ Removed 0.6x emblem size scaling"
> "✅ Removed viewport-size uniform from shaders"
> "✅ All rendering in canonical space, zoom only at display"

Translation: The codebase had accumulated MAGIC NUMBERS. The developer
was fighting coordinate system issues and decided to fix them systematically.

NEW ARCHITECTURE:
Pass 1: Render to 512x512 framebuffer (canonical space, -1 to +1)
Pass 2: Composite to viewport (apply zoom here)

Benefits Listed:
- "Clean separation: CoA rendering vs display"
- "Consistent coordinate system throughout"
- "Zoom doesn't affect CoA quality"

WHAT THE COMMIT DOESN'T SAY:
This refactor CHANGED how coordinates work. Now there are THREE coordinate
spaces instead of one:
1. Layer position (0-1 normalized)
2. OpenGL NDC (-1 to +1 in framebuffer)
3. Qt pixels (viewport space)

THE TRAP IS SET: The transform widget now needs coordinate conversion
functions to map between these spaces. But the layer data format didn't
change - it's still layer['pos_x'].


1.3 THE PARALLAX CRISIS - COORDINATE HELL BEGINS
-------------------------------------------------
Commits (Jan 27, 2026):
- 5481c3a "Fix transform widget parallax with coordinate conversion functions"
- 35cb4c7 "Fix Y-inversion and parallax by correcting RTT texture coordinates"
- fd9a616 "Fix parallax by accounting for composite quad base_size factor"

Three commits in rapid succession fixing THE SAME BUG. Let's examine why.

Commit 5481c3a introduced coordinate conversion functions:
```python
def layer_pos_to_opengl_coords(pos_x, pos_y):
    gl_x = (pos_x - 0.5) * 1.1
    gl_y = (pos_y - 0.5) * 1.1  # No inversion!
    return gl_x, gl_y

def layer_pos_to_qt_pixels(pos_x, pos_y, canvas_size, offset_x=0, offset_y=0):
    gl_x, gl_y = layer_pos_to_opengl_coords(pos_x, pos_y)
    pixel_x = gl_x * (canvas_size / 2)
    pixel_y = gl_y * (canvas_size / 2)
    qt_x = offset_x + canvas_size / 2 + pixel_x
    qt_y = offset_y + canvas_size / 2 - pixel_y  # Negate Y for Qt
    return qt_x, qt_y
```

THE PROBLEM: Magic number 1.1 appears. WHY?

Looking at commit 35cb4c7:
> "Fix Y-inversion and parallax by correcting RTT texture coordinates"

Translation: Y-axis was flipped wrong. OpenGL is Y-up, Qt is Y-down,
and the RTT texture has its own orientation.

Looking at commit fd9a616:
> "Fix parallax by accounting for composite quad base_size factor"

NEW magic number: VIEWPORT_BASE_SIZE = 0.8
This means the CoA only occupies 80% of the viewport!

PATTERN RECOGNITION: Each "fix" added a new factor:
- 1.1x for position scaling
- 0.8x for viewport size
- Various Y-inversions at different stages

WHY THIS MATTERS: The coordinate conversion functions became a DUMPING GROUND
for hacks. Every time rendering changed, someone added another factor.


1.4 THE COORDINATE SIMPLIFICATION
----------------------------------
Commit: 8b4a07d (Jan 27, 2026)
"Simplify coordinate system and fix transform widget dragging"

Finally, someone stopped and refactored properly:
- Added explicit VIEWPORT_BASE_SIZE constant
- Added COMPOSITE_SCALE constant (0.75)
- Updated conversion functions to account for both factors
- Fixed Y-inversion systematically

NEW conversion function:
```python
def layer_pos_to_opengl_coords(pos_x, pos_y):
    gl_x = pos_x * 2.0 - 1.0  # Map [0,1] to [-1,+1]
    gl_y = -(pos_y * 2.0 - 1.0)  # Invert: CK3 Y-down to OpenGL Y-up
    return gl_x, gl_y

def layer_pos_to_qt_pixels(...):
    # ... accounts for VIEWPORT_BASE_SIZE and COMPOSITE_SCALE ...
    pixel_x = gl_x * (canvas_size / 2) * VIEWPORT_BASE_SIZE * COMPOSITE_SCALE
    pixel_y = gl_y * (canvas_size / 2) * VIEWPORT_BASE_SIZE * COMPOSITE_SCALE
```

LESSON LEARNED: Coordinate conversion is HARD. It took 4 commits to get right.
And this pattern will repeat later...

CRITICAL OBSERVATION: Throughout ALL of this, layer data format never changed.
It's always been layer['pos_x']. The complexity is in CONVERSION, not storage.

================================================================================
PART II: THE EVOLUTION - MULTI-SELECTION ARCHITECTURE
================================================================================

2.1 SINGLE-SELECTION ERA (Jan 23-24, 2026)
-------------------------------------------
Commit: bc815fb
"Add interactive transform widget for layer manipulation"

Original transform logic:
```python
def _on_transform_changed(self, pos_x, pos_y, scale_x, scale_y, rotation):
    layer = self.property_sidebar.layers[selected_index]
    layer['pos_x'] = pos_x
    layer['pos_y'] = pos_y
    layer['scale_x'] = scale_x
    layer['scale_y'] = scale_y
    layer['rotation'] = rotation
    self.canvas_widget.set_layers(layers)
```

SIMPLE. DIRECT. WORKED PERFECTLY.

No caching, no AABB, no group transforms. Just read layer data, show widget,
write back on change.


2.2 MULTI-SELECTION IMPLEMENTATION (Jan 24, 2026)
--------------------------------------------------
Commit: 3e16de0
"Implement Phase 3: Multi-layer transform widget with group transforms"

+515 lines, -123 lines (massive change)

NEW CONCEPT: AABB (Axis-Aligned Bounding Box)
Instead of showing widget at one layer's position, calculate bounding box
of all selected layers.

Algorithm:
1. For each selected layer:
   - Get pos_x, pos_y, scale_x, scale_y
   - Calculate layer bounds: pos ± scale/2
2. Find min/max of all bounds → group AABB
3. Show widget at AABB center with AABB dimensions

Transform application:
1. Widget moves → calculate delta
2. Apply same delta to ALL layers
3. Widget scales → calculate scale_factor
4. Apply scale_factor to ALL layer scales AND positions (relative to center)

DESIGN DECISION: Preserve individual layer rotations
> "Preserved individual layer rotations during multi-layer operations"

WHY? Rotating individual layers would be destructive. User might want
to move a group while keeping individual emblem orientations.


2.3 THE CACHE PATTERN EMERGES
------------------------------
Looking at the multi-selection code from commit 3e16de0:

```python
# Cache original layer states at drag start to prevent cumulative transforms
if self._drag_start_layers is None:
    self._drag_start_layers = []
    for idx in selected_indices:
        layer = self.property_sidebar.layers[idx]
        self._drag_start_layers.append({
            'index': idx,
            'pos_x': layer.get('pos_x', 0.5),  # ← READS OLD FORMAT
            'pos_y': layer.get('pos_y', 0.5),
            'scale_x': layer.get('scale_x', 0.5),
            'scale_y': layer.get('scale_y', 0.5)
        })
```

WHY CACHE?
Without caching, each drag event would read current layer positions,
apply delta, and write back. But current positions INCLUDE previous deltas!
This causes cumulative error → layers accelerate away from mouse.

SOLUTION: Cache original positions at drag START. Calculate all transforms
relative to cached originals, not current values.

OBSERVATION: This cache still uses layer.get('pos_x') - the old format.
Because that's how layers have ALWAYS worked.


2.4 ROTATION IMPLEMENTATION (Jan 24-25, 2026)
----------------------------------------------
Commit: 3a05fd0
"Implement Tasks 3.2 & 3.6: Add group rotation transform for multi-layer selection"

NEW COMPLEXITY: Rotating a group is different from moving/scaling.

FERRIS WHEEL BEHAVIOR:
When widget rotates, layers should "orbit" around group center.
Individual layer rotations should NOT change (preserved).

Mathematics:
1. Calculate each layer's offset from group center
2. Rotate the offset vector
3. Apply rotated offset → new position
4. Keep individual rotation unchanged

Code (from later commits):
```python
if self.transform_widget.is_rotating:
    # ROTATION ONLY: Apply rotation to offset, no scaling
    rotation_rad = math.radians(rotation_delta)
    cos_r = math.cos(rotation_rad)
    sin_r = math.sin(rotation_rad)
    new_offset_x = offset_x * cos_r - offset_y * sin_r
    new_offset_y = offset_x * sin_r + offset_y * cos_r
    
    new_pos_x = original_center_x + new_offset_x + position_delta_x
    new_pos_y = original_center_y + new_offset_y + position_delta_y
    
    # Keep scales unchanged
    new_scale_x = scale_x_orig
    new_scale_y = scale_y_orig
```


2.5 THE AABB INFLATION SAGA - 8 BUG FIXES
------------------------------------------
Timeline of rotation-related bugs (Jan 25-26, 2026):

1. Commit 32ac853: "Fix rotation acceleration and widget travel issues"
2. Commit b695f51: "Fix AABB caching spam in multi-select scaling"
3. Commit 3e9d076: "Fix multi-select UX: layer ordering, AABB caching, rotation state"
4. Commit 48298fd: "Fix rotation causing scale corruption in multi-selection"
5. Commit 46ef431: "Fix group transform scaling by limiting cache sync to rotation only"
6. Commit a58e3b4: "Fix rotation AABB inflation preventing group scaling"
7. Commit 9d1d387: "Fix group rotation snapping on subsequent rotations"
8. Commit 8875fc5: "Fix Alt+mousewheel rotation for multi-selection"

WHAT WAS THE PROBLEM?

The AABB Inflation Issue (from commit a58e3b4):
> "After rotation, the widget's AABB expands to contain the rotated layers.
> On the next transform, the cached baseline didn't match the widget's
> inflated scale, causing issues."

VISUALIZATION:
```
Before rotation:          After rotation:
    +---+                    /-----\
    | □ |                   /   □   \
    +---+                  /_________\
  AABB = 100px           AABB = 141px (√2 expansion!)
```

When you rotate a square AABB, its bounding box grows by √2.
On next drag, widget thinks scale changed from 100→141, applies
141/100 = 1.41x scale factor → emblems EXPLODE.

THE FIX (evolved over multiple commits):
1. Cache the AABB when first calculated (before any rotation)
2. Use cached AABB whenever it exists
3. DON'T recalculate AABB after rotation
4. Clear cache only when selection changes

Additional complexity (commit 48298fd):
> "Sync cache if widget scale doesn't match cached scale"

When rotation ends, widget resets rotation to 0° and recalculates AABB.
Need to detect this and sync the cache to avoid scale mismatch.

PATTERN: This is sophisticated state management. Three different caches:
- self._drag_start_layers (per-drag operation)
- self._drag_start_aabb (per-drag group bounds)
- self.transform_widget.cached_aabb (persists across drags during selection)

WHY SO COMPLEX?
Because rotation is fundamentally different from translation/scale.
Translation/scale are LINEAR operations on the AABB.
Rotation is NON-LINEAR - it changes the AABB shape.


2.6 THE ARCHITECTURE PATTERN
-----------------------------
Looking at the final multi-selection code:

THREE DISTINCT CODE PATHS:
1. Single selection: Direct layer['pos_x'] read/write
2. Multi-selection translate/scale: Cached transforms with scale factors
3. Multi-selection rotation: Cached transforms with rotation matrix

Each path has different:
- Caching strategy
- Coordinate math
- State management

OBSERVATION: The code is BRANCHING. if len(selected)==1: ... else: ...
This branching exists in:
- update_transform_widget_for_layer() (shows widget)
- _on_transform_changed() (applies changes)

CRITICAL INSIGHT: All three paths still use layer['pos_x'] format.
Because that's the data model that's been there since Day 1.

================================================================================
PART III: THE PRESENT - WHY INSTANCING BROKE EVERYTHING
================================================================================

3.1 PHASE 2: MULTI-INSTANCE IMPLEMENTATION
-------------------------------------------
Recent commits (Jan 28-29, 2026):
- Changed layer data model from layer['pos_x'] to layer['instances'][i]['pos_x']
- Updated property_sidebar to read/write instances ✓
- Updated layer_operations to export instances ✓
- Updated file_operations to import instances ✓

WHAT WASN'T UPDATED:
- canvas_widget.py rendering loop
- canvas_area.py transform reading
- canvas_area.py transform writing


3.2 WHY THE OBVIOUS MISTAKE?
-----------------------------
Looking at git history provides the answer:

MUSCLE MEMORY: layer['pos_x'] has been the pattern for 170+ commits.
Every time you touch transform code, you write layer['pos_x'].

ARCHITECTURAL INERTIA: The transform system has THREE code paths
(single, multi-scale, multi-rotate). Updating one path is easy.
Updating ALL THREE paths in ALL THREE places (read/show/write) is 9 changes.

TESTING GAPS: The application "works" if you:
- Don't load files (no layers to render)
- Don't select layers (no transform widget)
- Don't drag transforms (no writes)

Each component was tested in isolation:
- property_sidebar works ✓ (they tested the sliders)
- layer_operations works ✓ (they tested import/export)
- But canvas_widget + canvas_area weren't tested together


3.3 THE COORDINATE PARALLEL
----------------------------
This instancing bug is IDENTICAL to the coordinate bugs from Jan 27.

Coordinate Bugs Pattern:
- Rendering used one coordinate system
- Transform widget used another
- Conversion functions added as band-aid
- Multiple commits to fix "parallax" issues

Instancing Bug Pattern:
- Rendering expects instances array
- Transform widget expects direct properties
- Migration function added as band-aid
- Multiple commits to fix... (in progress)

SAME UNDERLYING ISSUE: Architectural mismatch between components.


3.4 THE PREVENTION THAT WASN'T
-------------------------------
Looking at property_sidebar.py (the one that WAS fixed):

```python
def get_property_value(self, property_name):
    # Instance properties are stored within instances list
    instance_properties = ['pos_x', 'pos_y', 'scale_x', 'scale_y', 'rotation', 'depth']
    
    if property_name in instance_properties and 'instances' in layer:
        instances = layer.get('instances', [])
        selected_inst = layer.get('selected_instance', 0)
        if 0 <= selected_inst < len(instances):
            return instances[selected_inst].get(property_name)
```

DEFENSIVE PROGRAMMING: Check if property is instance-specific,
check if instances exist, check if index is valid.

WHY WASN'T THIS PATTERN USED EVERYWHERE?
Because canvas_area.py was written when the pattern didn't exist yet.
It predates the abstraction.


3.5 THE COPY-PASTE ARCHAEOLOGY
-------------------------------
Examining canvas_area.py closely:

Lines 206-215: Single-selection read
Lines 233-246: Multi-selection AABB calculation
Lines 316-325: Multi-selection cache initialization
Lines 288-296: Single-selection write
Lines 435-444: Multi-selection write

OBSERVATION: All five locations have nearly IDENTICAL code:
```python
pos_x = layer.get('pos_x', 0.5)
pos_y = layer.get('pos_y', 0.5)
scale_x = layer.get('scale_x', 0.5)
scale_y = layer.get('scale_y', 0.5)
```

This is COPY-PASTE programming. Same pattern repeated 5 times.
To fix instancing, need to update ALL FIVE independently.

WHY NO HELPER FUNCTION?
Because each location has subtle differences:
- Location 1: Needs rotation too
- Location 2: Inside loop, needs continue on error
- Location 3: Inside loop, building cache dict
- Location 4: Writing back with clamping
- Location 5: Writing back inside transform loop

REFACTORING OPPORTUNITY: Could have helper:
```python
def get_selected_instance_transform(layer):
    instances = layer.get('instances', [])
    selected = layer.get('selected_instance', 0)
    if instances and 0 <= selected < len(instances):
        inst = instances[selected]
        return inst.get('pos_x'), inst.get('pos_y'), inst.get('scale_x'), ...
    return defaults
```

But this abstraction doesn't exist because the need wasn't recognized.

================================================================================
PART IV: LESSONS FROM HISTORY
================================================================================

4.1 PATTERN: COORDINATE SYSTEMS ARE HARD
-----------------------------------------
Evidence: 40+ commits fixing coordinate/parallax issues

ROOT CAUSE: Multiple coordinate spaces with conversions
- Layer space (0-1)
- OpenGL NDC (-1 to +1)
- Framebuffer space (512x512)
- Qt pixels (variable)

LESSON: When you have >2 coordinate systems, create explicit conversion
functions and UNIT TEST them. Don't add hacks as issues arise.


4.2 PATTERN: STATE MACHINES IN DISGUISE
----------------------------------------
The transform system is actually a STATE MACHINE:
- State 1: No selection → widget hidden
- State 2: Single selection → direct control
- State 3: Multi-selection not rotating → AABB with scale
- State 4: Multi-selection rotating → AABB with rotation matrix

Evidence: Multiple boolean flags (is_rotating, _aabb_synced, cached_aabb!=None)

LESSON: When you find yourself with 3+ boolean flags controlling behavior,
you have a state machine. Make it explicit:
```python
class TransformMode(Enum):
    NONE = 0
    SINGLE = 1
    MULTI_TRANSLATE = 2
    MULTI_SCALE = 3
    MULTI_ROTATE = 4
```


4.3 PATTERN: CACHE INVALIDATION IS HARD
----------------------------------------
Evidence: 8 commits fixing AABB caching bugs

THREE DIFFERENT CACHES:
1. Per-drag cache (_drag_start_layers)
2. Per-drag AABB (_drag_start_aabb)
3. Per-selection AABB (cached_aabb)

Each has different lifetime:
1. Cleared when mouse released
2. Cleared when mouse released
3. Cleared when selection changes

LESSON: Document cache lifetime explicitly. Consider using a CacheManager:
```python
class TransformCache:
    def __init__(self):
        self.drag_layers = None     # Valid during drag only
        self.drag_aabb = None        # Valid during drag only
        self.selection_aabb = None   # Valid for selection lifetime
    
    def on_drag_start(self): ...
    def on_drag_end(self): ...
    def on_selection_change(self): ...
```


4.4 PATTERN: DATA MODEL MIGRATION
----------------------------------
Evidence: Current instancing bug

MIGRATION STRATEGIES USED:
1. Migration function: _migrate_layer_to_instances()
2. Defensive gets: layer.get('instances', [])
3. Fallback defaults: if not instances: return defaults

WHAT'S MISSING:
- No deprecation warnings
- No runtime checks for old format
- No automated migration in setters

BETTER APPROACH:
```python
class Layer:
    @property
    def pos_x(self):
        # Backward compatibility: try old format first
        if 'pos_x' in self._data:
            warnings.warn("Direct pos_x access deprecated")
            self._migrate_to_instances()
        return self.get_selected_instance()['pos_x']
    
    @pos_x.setter
    def pos_x(self, value):
        self.get_selected_instance()['pos_x'] = value
```


4.5 PATTERN: ARCHITECTURAL COMPLEXITY CREEP
--------------------------------------------
Evolution timeline:
Day 1: Simple direct rendering
Day 2: Added RTT (2 passes)
Day 3: Added coordinate conversions
Day 4: Added multi-selection
Day 5: Added rotation
Day 6-7: Fixed 20+ edge cases

COMPLEXITY METRICS:
- canvas_widget.py: 1227 lines
- canvas_area.py: 490 lines
- transform_widget.py: 758 lines
Total: 2475 lines for transform/rendering

LESSON: Complexity grows exponentially with features.
Initial design (300 lines) grew 8x in one week.


4.6 PATTERN: THE ABSENCE OF TESTS
----------------------------------
Evidence: No unit tests found in repository

WHAT COULD HAVE BEEN TESTED:
- Coordinate conversion functions (pure functions!)
- AABB calculation (deterministic math)
- Transform cache invalidation
- Layer data migration

WHY NO TESTS?
- Rapid prototyping (tests slow you down initially)
- GUI application (hard to test)
- Single developer (no code review)

COST OF NO TESTS:
- 20+ bug fix commits for same system
- Current instancing bug undetected until runtime
- Each fix risking regression

================================================================================
PART V: THE PREDICTION - WHY PHASE 2 WILL TAKE 3 DAYS
================================================================================

5.1 HISTORICAL PATTERNS PREDICT FUTURE
---------------------------------------
Based on git history patterns:

COORDINATE FIXES: 6 commits over 2 days
MULTI-SELECT FIXES: 15 commits over 3 days
ROTATION FIXES: 8 commits over 2 days

PREDICTION FOR INSTANCING:
~10-15 commits over 2-3 days

Why? Same architectural mismatch pattern:
- Multiple code paths to update (9 locations)
- Subtle differences in each location
- Edge cases (empty instances, invalid index)
- Interaction bugs (caching, AABB, rotation)


5.2 THE FIX SEQUENCE (Predicted)
---------------------------------
Based on historical bug fix patterns:

Commit 1: "Fix rendering to use instances array"
- Update canvas_widget.py render loop
- Add nested loop over instances
- Test: Layers render again

Commit 2: "Fix transform widget to read instances"
- Update canvas_area.py read locations
- Test: Widget shows at correct position

Commit 3: "Fix transform widget to write instances"
- Update canvas_area.py write locations
- Test: Dragging updates data

Commit 4: "Fix multi-selection AABB with instances"
- AABB calculation reads instances
- Test: Multi-select widget positioned correctly

Commit 5: "Fix multi-selection cache with instances"
- Cache initialization reads instances
- Test: Multi-drag doesn't accelerate

Commit 6: "Fix multi-selection write with instances"
- Transform application writes instances
- Test: Multi-drag actually updates layers

Commits 7-12: Edge cases discovered during testing
- "Fix empty instances array crash"
- "Fix invalid selected_instance index"
- "Fix AABB inflation with instance rotation"
- "Fix cache corruption when switching instances"
- "Fix undo/redo with instances"
- "Fix copy/paste instance selection"


5.3 THE RISKS
--------------
Based on historical similar bugs:

HIGH RISK: AABB Caching
The rotation cache system is FRAGILE. Adding instances might break:
- Cache key (currently uses layer index, now needs instance index too?)
- Cache invalidation (selection change vs instance change)
- Cache sync logic (see commit 48298fd complexity)

MEDIUM RISK: Off-by-one errors
selected_instance is 0-based index. Classic bugs:
- Accessing instances[selected_instance] without bounds check
- Forgetting instances can be empty []
- Mixing up layer index vs instance index

LOW RISK: Rendering
Rendering is most straightforward: just add a loop.
The math doesn't change, just repeat it per instance.


5.4 THE CORRECT APPROACH (History's Lesson)
--------------------------------------------
Based on what SHOULD have been done for coordinates:

STEP 1: Create abstraction layer
```python
# layer_accessor.py
class LayerAccessor:
    @staticmethod
    def get_transform(layer, instance_index=None):
        instances = layer.get('instances', [])
        idx = instance_index if instance_index is not None else layer.get('selected_instance', 0)
        
        if not instances or idx >= len(instances):
            return defaults
        
        inst = instances[idx]
        return {
            'pos_x': inst.get('pos_x', 0.5),
            'pos_y': inst.get('pos_y', 0.5),
            'scale_x': inst.get('scale_x', 0.5),
            'scale_y': inst.get('scale_y', 0.5),
            'rotation': inst.get('rotation', 0)
        }
    
    @staticmethod
    def set_transform(layer, transform, instance_index=None):
        instances = layer.get('instances', [])
        idx = instance_index if instance_index is not None else layer.get('selected_instance', 0)
        
        if not instances or idx >= len(instances):
            return False
        
        instances[idx].update(transform)
        return True
```

STEP 2: Replace all direct access with accessor
- Search for layer['pos_x'] and layer.get('pos_x')
- Replace with LayerAccessor.get_transform(layer)['pos_x']
- ~50 replacements across codebase

STEP 3: Add deprecation warnings
- Wrap layer dict in LayerDict subclass
- Override __getitem__ to warn on direct access
- Run application, collect all warnings, fix them

STEP 4: Write tests
- Test accessor with old format (backward compat)
- Test accessor with new format
- Test accessor with edge cases (empty, invalid index)
- Test accessor with multiple instances

WHY THIS WASN'T DONE:
- Time pressure (rapid development)
- Hindsight (pattern not obvious until too late)
- Single developer (no code review suggesting this)

================================================================================
PART VI: THE META-LESSON
================================================================================

6.1 TECHNICAL DEBT COMPOUNDS
-----------------------------
Timeline of debt accumulation:

Day 1: Direct access pattern (layer['pos_x'])
  ↓ Seems fine, copy-paste throughout code
Day 3: RTT requires coordinate conversions
  ↓ Add conversion functions, keep layer format
Day 4: Multi-selection requires caching
  ↓ Cache uses direct access pattern
Day 5: Rotation requires special caching
  ↓ More code using direct access
Day 7: Phase 2 changes data model
  ↓ 200+ lines of code use old pattern
  ↓ 9 specific locations in transform system
  ↓ Fixing requires touching ALL locations
  ↓ Each fix risks breaking others

COMPOUNDING EFFECT: Each day's code depends on previous days' patterns.
By Day 7, changing the pattern requires rewriting 40% of the codebase.


6.2 GOOD DECISIONS THAT HELPED
-------------------------------
Despite issues, some decisions SAVED the project:

1. Coordinate Conversion Functions (commit 5481c3a)
   - Centralized coordinate math
   - Made later fixes possible
   - Could be extended for instances

2. Migration Function (layer_operations.py)
   - _migrate_layer_to_instances() is automatic
   - Backward compatibility preserved
   - Old files still load

3. Defensive Gets (throughout)
   - layer.get('pos_x', 0.5) instead of layer['pos_x']
   - Prevents KeyError crashes
   - Allows gradual migration

4. Git History (entire project)
   - Detailed commit messages explain WHY
   - Easy to understand evolution
   - Rollback is safe


6.3 THE HUMAN ELEMENT
----------------------
Looking at commit messages reveals the developer's thought process:

EARLY COMMITS (Day 1-2):
"Add interactive transform widget"
→ Confident, implementing new features

MIDDLE COMMITS (Day 3-5):
"Fix parallax by accounting for..."
"Fix Y-inversion and parallax..."
"Fix transform widget parallax..."
→ Fighting unexpected bugs, trying different approaches

LATE COMMITS (Day 6-7):
"Fix rotation AABB inflation preventing group scaling"
"Fix group transform scaling by limiting cache sync to rotation only"
→ Sophisticated understanding, surgical fixes

PATTERN: Developer learned the system by building it, hit architectural
limits, evolved the architecture, then hit those limits again.

THIS IS NORMAL SOFTWARE DEVELOPMENT.


6.4 THE INSTANCING DECISION - WHY NOW?
---------------------------------------
Why was Phase 2 (multi-instance) implemented AFTER the transform system?

THEORY 1: CK3 Game Format Requirements
Looking at game_samples, CK3 format supports multiple instances:
```
colored_emblem = {
    texture = "ce_eagle.dds"
    instance = [
        { position = [...] scale = [...] }
        { position = [...] scale = [...] }  # Multiple!
    ]
}
```

The editor MUST support this to be a proper CK3 editor.

THEORY 2: Feature Creep
Initially, single instance seemed sufficient. But then:
- User wants to duplicate emblem → manual copy-paste
- User wants same emblem in 3 positions → create 3 layers
- User realizes this is tedious → request multi-instance feature

THEORY 3: Parallel Development
Evidence: Phase 2 changes isolated to specific files.
Maybe Phase 2 was being developed in parallel, merged later?

Git log doesn't show branches, but large Phase 2 commits suggest
batch integration rather than incremental development.


================================================================================
PART VII: THE RECOMMENDATION
================================================================================

7.1 IMMEDIATE FIX STRATEGY
---------------------------
Based on historical success patterns:

APPROACH: Surgical fixes, not refactor
- Update 9 specific locations
- Keep existing architecture
- Add defensive checks
- Test incrementally

WHY NOT REFACTOR:
- Refactors in history took 2-3 days
- Current code works (just wrong format)
- Risk of breaking working features (rotation, AABB)

SEQUENCE:
1. Fix rendering (immediate visual feedback)
2. Fix transform reading (widget positioning)
3. Fix transform writing (persistence)
4. Fix edge cases (crashes, invalid state)


7.2 MEDIUM-TERM IMPROVEMENTS
-----------------------------
After Phase 2 is stable:

1. Create LayerAccessor abstraction
   - Wrap all instance access
   - Add deprecation warnings
   - Prevent future direct access

2. Add coordinate system tests
   - Test layer_pos_to_opengl_coords()
   - Test layer_pos_to_qt_pixels()
   - Test AABB calculation

3. Document state machine
   - Create state diagram for transform modes
   - Document cache lifetimes
   - Add assertions for invalid states


7.3 LONG-TERM ARCHITECTURE
---------------------------
If rebuilding from scratch (Phase 3?):

1. Separate Model from View
   - Layer data: Pure data class
   - Canvas: Pure rendering
   - Transform: Pure UI widget
   - Coordinator: Manages interactions

2. Use Property Accessors
   - layer.pos_x (property, not dict key)
   - layer.selected_instance (property)
   - Automatic migration, validation

3. Explicit State Machine
   - TransformMode enum
   - State transitions documented
   - No hidden boolean flags

4. Comprehensive Tests
   - Unit tests for math
   - Integration tests for interactions
   - Regression tests for known bugs


7.4 THE PHILOSOPHICAL LESSON
-----------------------------
This project demonstrates a fundamental truth:

SOFTWARE DEVELOPMENT IS ARCHAEOLOGY.

You're constantly digging through layers of past decisions.
Each layer made sense at the time.
But accumulated layers create complexity.

The instancing bug isn't a "mistake" - it's INEVITABLE COMPLEXITY.
Any system that evolves over time will have mismatches between components
built at different times under different constraints.

The question isn't "how do we avoid this?" (you can't).
The question is "how do we manage this?" (documentation, tests, refactoring).

This document is that management.

================================================================================
END OF CHRONICLE
================================================================================

APPENDIX A: Key Commits Referenced
-----------------------------------
bc815fb - Initial transform widget (Jan 23)
8e7a364 - RTT rendering refactor (Jan 27)
5481c3a - Coordinate conversion functions (Jan 27)
8b4a07d - Coordinate simplification (Jan 27)
3e16de0 - Multi-selection implementation (Jan 24)
3a05fd0 - Rotation implementation (Jan 24)
48298fd - Scale corruption fix (Jan 25)
a58e3b4 - AABB inflation fix (Jan 25)

APPENDIX B: Pattern Frequency
------------------------------
"Fix" commits: 78 out of 174 (45%)
"Implement" commits: 42 out of 174 (24%)
"Add" commits: 38 out of 174 (22%)
"Refactor" commits: 7 out of 174 (4%)

Translation: Almost half of development was fixing bugs.
This is typical for complex UI systems.

APPENDIX C: The Final Irony
----------------------------
The fix for instancing is SIMPLE: read from instances[selected_instance].
The reason it's hard: 200 lines of code doing it wrong.
The reason for those 200 lines: Evolution over 7 days.
The reason for that evolution: Each feature needed more complexity.
The reason for complexity: CK3's coat of arms system is genuinely complex.

Everything makes sense in retrospect.
Nothing could have been predicted at the start.
That's software.

================================================================================
