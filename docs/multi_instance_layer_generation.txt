MULTI-INSTANCE LAYER GENERATION FEATURE
========================================

OVERVIEW
--------
Feature to generate layers with multiple instances arranged according to various patterns.
Allows users to quickly create complex CoA designs without manually placing each instance.

CORE CONCEPTS
-------------
- Generate a single layer containing multiple instances
- Apply generation patterns to automatically position/transform instances
- Configurable parameters for each pattern type

MENU STRUCTURE
--------------
Menu: "Generate" with subcategories:
- Path (circular, line, spiral)
  - Shape (auto-populated from editor/assets/svg/*.svg files)
- Grid (grid pattern, diamond grid)
- Vanilla (CK3 official layouts)
- Misc (fibonacci spiral, radial, star path)

Example: testSVG.svg → Generate > Path > Shape > testSVG

GENERATION PATTERNS
-------------------

PROCEDURAL PATTERNS (User-Configurable):

PATH CATEGORY:

Common Parameters (all path patterns):
- Radio buttons: "Count" or "Text" (mutually exclusive)
  - Count mode: Shows count parameter (number of instances)
  - Text mode: Shows text_input box for entering text (only vanilla text emblems)
  - When Text mode selected, each character becomes an instance along the path
  - Note: Text mode only available for PATH category patterns (not Grid, Misc, or Vanilla)
  
**IMPORTANT - Text Mode Limitation:**
Text mode creates MULTIPLE LAYERS, not a multi-instance layer!
- Each letter requires a different emblem (different texture)
- Cannot use multi-instance system (instances share same emblem)
- Will create one layer per character
- Warning displayed to user before generation

Text Emblem Mapping:
- Grep for available text emblems (ce_text_*.dds pattern)
- Create whitelist of available characters for textbox validation
- Lookup table: character → ce_text_[char] (e.g., A → ce_text_a)
- Spaces are skipped (no layer created)
- If character has no emblem, skip it
- Invalid characters silently ignored (as if key never pressed)
- 100 character limit enforced
- Invalid characters silently ignored (as if key never pressed)
- 100 character limit enforced

- start_scale, end_scale: Scale variation from start to end of path
  - Default: Single scale value (uniform scaling, default = 1.0)
  - Checkbox: "Enable gradient" unlocks separate start_scale, end_scale
- rotation_mode: "global" (all same rotation) or "aligned" (follow path direction)
  - Default: global
- base_rotation: Angle added to rotation (0° for global, path tangent for aligned)
- start_angle, end_angle: Angular range for pattern (in degrees)
  - Default: 0-360°

1. Circular Pattern
   - Arrange instances in a circle (or arc)
   - Unique Parameters: radius

2. Line Pattern
   - Arrange instances along a line
   - No unique parameters (uses count and start/end angles for spacing)

3. Spiral Pattern
   - Arrange instances in a spiral
   - Unique Parameters: start_radius, end_radius, turns (1 turn = 360°, e.g., 2.5 turns = 900°)

SHAPES SUB-CATEGORY (Preset Path Fills):
Note: Uses path_percent instead of angles (0-100%, where 100% = full perimeter)
Auto-populated from editor/assets/svg/*.svg files

Popup UI:
- Shape patterns open popup with dropdown to select different shapes
- Allows switching between shapes without closing popup
- All shapes share same generator backend (ShapeGenerator)
- Same parameters regardless of shape selected

Common Parameters (all shape patterns):
- Radio buttons: "Count" or "Text" (mutually exclusive)
- start_percent, end_percent: Portion of path (0-100%)
  - Default: 0-100%
- Scale controls:
  - Default: Single scale value (uniform scaling, default = 1.0)
  - Checkbox: "Enable gradient" - unlocks start_scale, end_scale separately
- rotation_mode: "global" or "aligned" (follow path direction)
  - Default: global
- base_rotation: Angle added to rotation
- Inset: Fixed constant (DEFAULT_INSET = 0.02), not user-adjustable

Shape patterns are dynamically loaded from SVG files:
- Each .svg file in editor/assets/svg/ becomes a menu item
- Example: shield_heater.svg → Generate > Path > Shape > shield_heater
- No hardcoded shape list - add new SVG files to add new shapes
- Inset is fixed constant (DEFAULT_INSET = 0.02), not user-adjustable
- User expected to use transform tools for precise positioning

Popup UI:
- Shape patterns open popup with dropdown to select different shapes
- Allows switching between shapes without closing popup
- All shapes share same generator backend (ShapeGenerator)
- Same parameters regardless of shape selected

GRID CATEGORY:
8. Grid Pattern
   - Arrange instances in rows and columns
   - Fills space based on row/column count (user resizes after generation)
   - Parameters: rows, columns

9. Diamond Grid Pattern
    - Checkerboard-style staggered grid (alternating row offsets)
    - Can create 50 Stars arrangement (9 rows, 6-5 alternating pattern)
    - Can be squashed to create isometric appearance
    - Fills space based on row/column count (user resizes after generation)
    - Stagger offset is fixed constant
    - Parameters: rows, columns

MISC CATEGORY:
10. Fibonacci Spiral Pattern (Sunflower)
    - Even radial distribution using golden angle (phi ~137.5°)
    - Natural sunflower seed arrangement for uniform filling
    - Auto-scales to fit 1x1 square with padding
    - More points = smaller individual instances
    - Parameters: count

11. Radial Pattern
    - Arrange instances radiating from center (distinct rays)
    - May use multiple lines per ray depending on implementation
    - Unique Parameters: min_radius, max_radius

12. Star Path Pattern
    - Arrange instances along star outline (distinct lines per point)
    - Similar to radial but follows star shape
    - Unique Parameters: points, radius

Note: Radial and Star Path moved to Misc for further design consideration

VANILLA CATEGORY:

VANILLA CATEGORY:
CK3 OFFICIAL LAYOUTS:
Extracted from game/gfx/coat_of_arms/emblem_layouts/50_coa_designer_emblem_layouts.txt
via asset converter tool

Popup UI:
- Vanilla layouts DO open a popup (not instant application)
- Popup includes dropdown to select different vanilla layouts
- Allows switching between layouts without closing popup
- All vanilla layouts share same generator backend
- No parameters (just preview and layout selector dropdown)

Process:
- Game files store layouts as templates with adjustable variables
- Asset converter extracts these templates (TODO: add this functionality)
- We process and flatten them into usable static data
- Extract instance data only (positions, scales, rotations)
- Store in JSON file as 5xN numpy arrays per layout: [x, y, scale_x, scale_y, rotation]
- Format: {"layout_name": [[x,y,sx,sy,r], [x,y,sx,sy,r], ...], ...}
- All generator position outputs should use 5xN numpy array format before converting to layers

Note: Asset converter currently handles textures/metadata only.
Needs extension to parse and process emblem layout files.

Layouts include:
- single_centre: 1 instance at center
- diagonal_duo: 2 instances diagonal
- diagonal_trio: 3 instances diagonal
- layout_9: 33 instances in 5×7 grid
- layout_11: Mirrored pair (negative scale for mirroring)
- layout_14-34: Various decorative arrangements (30+ total layouts)

Note: CK3 layouts are applied instantly with predefined positions/scales.
No runtime variable processing - all layouts pre-calculated.
Procedural patterns allow user configuration before generation.

ARCHITECTURE
------------
Location: services/layer_generator.py

Popup Architecture:
- Single reusable GeneratorPopup dialog (singleton or managed instance)
- Generator objects load into the popup (not separate dialogs per pattern)
- Generator lifecycle: created → loaded into popup → unloaded/destroyed
- Popup remains, generators are swapped in/out

Classes:
- GeneratorPopup: The singular popup dialog (reusable container)
- BaseGenerator: Base class for all generator objects
  - Provides get_title() method: Returns display title for popup
  - Provides UI builder method: build_controls(parent_widget)
  - Provides position generation method: generate_positions(**params)
  - Hooks into popup's callbacks for preview updates
- Pattern generator classes: GridGenerator, CircularGenerator, etc. (inherit from BaseGenerator)
- ShapeGenerator: Single class for all SVG shape patterns
  - Constructor takes svg_filename parameter
  - Same generator code, different SVG path data
  - Example: ShapeGenerator("shield_heater.svg")
  - get_title() returns shape name from filename

UI Architecture:
- GeneratorPopup provides:
  - Preview widget (left side, fixed 300x300)
  - Controls container (right side, dynamic)
  - Generate/Cancel buttons
- Generator object provides controls via build_controls():
  - Can use generic UI builder methods for common parameters:
    - add_count_text_radio() - Count vs Text mode selector
    - add_scale_controls() - start_scale, end_scale sliders
    - add_rotation_controls() - rotation_mode, base_rotation
    - add_angle_controls() - start_angle, end_angle
    - add_percent_controls() - start_percent, end_percent
  - Each generator adds unique parameter controls
  - Reduces duplication, maintains consistency

Integration Points:
- Menu selection creates generator object and loads it into popup
- Right-click creates generator object with pre-selected asset
- CoA Model: Use paste system to add generated layer with instances

WORKFLOW
--------
1. User selects pattern from menu hierarchy:
   - Generate > Path > Circular
   - Generate > Grid > Isometric
   - Generate > Vanilla > diagonal_duo
   - etc.
   Alternative: Right-click asset in asset sidebar → "Generate with this"
   - Opens generator with that asset pre-selected
2. Popup dialog opens with:
   - Pattern-specific parameter controls (sliders, spinboxes)
   - Live preview area showing simplified render
3. User configures pattern parameters
4. Preview updates in real-time showing arrangement
5. User clicks "Generate" button
6. If Text mode is enabled:
   - Display warning: "Text mode will create multiple layers (one per character), not a single multi-instance layer. Continue?"
   - User confirms or cancels
7. New layer(s) created in CoA using paste system
8. Popup closes

TECHNICAL DETAILS
-----------------
- Use CoA methods to create layer and add instances
- Generate instance UUIDs for each instance
- Calculate positions/transformations based on pattern
- Respect CoA coordinate system and bounds
- Support undo/redo functionality
- Undo/Redo: Layer generation is a SINGLE operation
  - No matter how many instances are created
  - One undo removes the entire generated layer
  - Treated as atomic operation

Settings Persistence:
- Generator settings are saved per pattern type
- When reopening same generator, last settings are restored
- Settings include: count/text, scales, rotation mode, angles, etc.
- Stored in memory during session (not persisted to disk)
- Each generator type (circular, grid, etc.) maintains its own settings

Emblem/Color/Mask Selection:
- Generated layers use default emblem (can be changed after generation)
- Default colors applied (can be changed after generation)
- Default masks applied (can be changed after generation)
- User edits properties post-generation using property sidebar

Pattern Selection UI:
- Menu hierarchy (Generate > Category > Pattern)
  - Example: Generate > Path > Circular
  - Example: Generate > Grid > Isometric
  - Example: Generate > Path > Shape > shield_heater
- Alternative: Right-click context menu on asset sidebar
  - Right-click any asset → "Generate with this"
  - Opens generator popup with that asset pre-selected for use
  - User still chooses pattern type in submenu

Default Parameter Values:
- Define as tunable constants (specific values TBD)
- Examples: DEFAULT_COUNT, DEFAULT_SCALE, DEFAULT_ROTATION, etc.
- DEFAULT_INSET = 0.02 (for shield shape patterns)
- Allow easy adjustment during development/testing

Preview Coordinate Mapping:
- CoA coordinate space: 0.0 to 1.0
- Preview widget: 300x300 pixels
- Mapping: 0.0 → 0px, 1.0 → 300px (linear scaling)
- Center (0.5, 0.5) → (150px, 150px)

Validation and Limits:
- Define as tunable constants
- MAX_INSTANCE_COUNT = 100 (performance limit)
- Generators must produce at least 1 instance (no empty generation)
- Parameter ranges (min/max for scales, counts, etc.)
  - Limits imposed by nature (e.g., count >= 1) or constants
- Error messages for invalid inputs

Settings Persistence:
- Settings ALWAYS saved on popup close (even Cancel/X button)
- Users are clumsy - preserve their work
- Settings persist per generator type during session

Preview Performance:
- Real-time updates on parameter change (if performant enough)
- Generate positions for up to 100 instances on each update
- Consider throttling/debouncing if performance issues arise

Instance Transform Order:
- Follows CK3 CoA rules (see CoA documentation)
- Transform order dictated by game engine

Color Slots:
- All color slots set to default values
- User changes colors after generation via property sidebar

Frame Bounds Awareness:
- Patterns do NOT respect current frame shape
- Use regular bounds rules (0-1 coordinate space)
- Ignore frame mask boundaries

CoA Integration Method:
- Prefer using existing paste system for layer creation
- Leverages existing undo/redo infrastructure
- Consistent with other layer creation operations

Layer Insertion Position:
- No selection: Insert at top (visually front-most)
- With selection: Insert above selected layer (visually in front of it)

Preview Update Mechanism:
- Generator emits signal/callback when parameters change
- Popup listens and requests new positions via generate_positions()
- Preview widget redraws with new positions

Generator Lifecycle/Cleanup:
- When switching generators: whatever's least painful to implement
- Save settings before destruction/unload
- Clean up widgets from controls container

Right-Click Asset Behavior:
- Works on all asset types (emblems, patterns, etc.)
- Uses emblem under mouse instead of default fleur
- Still opens generator selection submenu
- Asset selection passing: TBD during implementation
  - Option 1: Pass asset data to generator constructor
  - Option 2: Generator has set_asset() method
  - Option 3: Store selected asset globally, generator queries it
- Asset selection approach: TBD
  - Option 1: Pass asset data to generator constructor
  - Option 2: Generator has set_asset() method
  - Option 3: Store selected asset globally and generator queries it
  - Decide during implementation

Angle/Rotation Coordinate System:
- 0° = emblem's natural orientation
- Angles measured clockwise from vertical (bearing system)
- Range: 0-359 degrees

Error Handling During Generation:
- Raw fail if something breaks (it's our fault)
- No graceful error recovery - fix bugs instead

Preview Aspect Ratio:
- Always square (300x300) regardless of CoA viewport shape
- CoA coordinate space (0-1) maps to preview (0-300) linearly

SVG PATH HANDLING (for SHAPES patterns)
----------------------------------------
Custom shapes (shields, box, star, triangle) use SVG path data:

Storage:
- SVG files stored in editor/assets/svg/ folder
- Named by shape: shield_heater.svg, shield_norman.svg, shield_french.svg, etc.
- All paths normalized to -0.5 to 0.5 coordinate square
- Normalization preserves aspect ratio:
  - Longest dimension (width or height) scaled to fill 1.0 span (-0.5 to 0.5)
  - Shorter dimension scaled proportionally
  - Shape centered within the square
  - Example: Tall shape → full height, narrower width, horizontally centered
  - Example: Wide shape → full width, shorter height, vertically centered
- You provide exact SVG files (no guessing at shield shapes)

Preloading Strategy:
- All SVG files loaded and processed at application startup
- SVG paths converted to PathSampler objects (discretized polylines)
- Pre-calculation happens once, stored in memory
- ShapeGenerator instances reference pre-loaded PathSampler objects
- No runtime SVG parsing overhead
- Error Handling: If SVG fails to load/parse, skip it entirely
  - Failed SVGs are not added to menu
  - Only valid, successfully loaded shapes appear in Generate > Path > Shape
  - Log errors for debugging but don't break application

Path Sampler Service:
- Loads SVG file and extracts <path d="..."> data
- Converts ALL paths to simple dot-to-dot polylines (list of (x, y) points)
- No curves in final representation - everything is straight line segments
- Discretizes SVG curves (bezier, arcs, etc.) into line segments during conversion
- Configurable resolution for curve discretization (higher = smoother approximation)
- No simplification pass needed (data size is small - handful of shapes, few hundred points each)
- Pre-calculates segment lengths for fast queries
- Measures total path length for effective sampling
  - Cumulative length at each point (for length-based queries)
  - Total perimeter/length available for percent-based sampling
  - Consider using numpy for efficient distance calculations between points

Query Methods:
- sample_points(count, start_percent, end_percent) -> List[(x, y, angle)]
- Evenly spaces points along path using length-based sampling
- Returns position + tangent angle for each point
- Uses linear interpolation within segments
- O(n) lookup time using pre-calculated cumulative lengths

SVG Path Support:
- M/m (moveto)
- L/l (lineto)
- H/h (horizontal lineto)
- V/v (vertical lineto)
- C/c (cubic bezier) - discretized into line segments
- Q/q (quadratic bezier) - discretized into line segments
- Z/z (closepath)

Workflow for Adding Custom Shapes:
1. Draw shape in SVG editor (Inkscape, Illustrator)
2. Normalize to -0.5 to 0.5 coordinate space
3. Save as .svg file in editor/assets/svg/
4. Path automatically loaded, discretized and queryable

PREVIEW SYSTEM
--------------
- Simplified render in popup dialog preview area using QPainter
- Preview renderer takes list of instance transforms:
  - Position (x, y)
  - Scale (scale_x, scale_y)
  - Rotation (angle)
- No full CoA rendering needed - just shape placeholders
- Real-time update as parameters change
- Lightweight rendering for responsive UI

Popup Layout:
- Split horizontal layout
- LEFT side: Preview widget (~300x300 pixels square with border) - fixed size
- RIGHT side: Properties/controls panel - extends to fill remaining space
- Preview has visible border to separate it from the rest of the popup
- Properties panel width adapts to content/line length
- Split position is fixed against the preview edge
- Title bar: X button to close popup (same as Cancel)
- Bottom buttons: "Generate" and "Cancel"
  - Generate: Creates the multi-instance layer and closes popup
  - Cancel: Closes popup without creating layer
  - X button: Closes popup without creating layer

Preview Visual Design:
- Background: Black (#000000)
- Instance representation: White square with red triangle quarter
- Red triangle: Corner fold (like envelope flap) at top-left corner
- Triangle acts as directional indicator showing orientation/rotation
- Each instance applies position, scale, and rotation transforms


IMPLEMENTATION PHASES
---------------------
Phase 1: Core infrastructure
  - LayerGenerator service
  - Basic pattern classes
  - Integration with CoA model
  - Unit tests for all generators (position generation, parameter validation)

Phase 2: UI components
  - Generation popup dialog
  - Pattern parameter controls
  - Simplified preview renderer
  - Real-time preview updates

Phase 3: Advanced patterns
  - More complex patterns
  - Custom pattern support
  - Pattern presets

Phase 4: Polish
  - Optimize preview rendering
  - Pattern library
  - Save/load pattern configurations
  - Preset patterns for common arrangements

NOTES
-----
- All layer manipulation must go through CoA API
- Use UUID-based layer identification
- Avoid direct access to coa._layers
- Follow component responsibility principle
- Use specific CoA methods, not generic getters/setters
- Settings always persist (even on Cancel/X) - users are clumsy
- No empty generation allowed (min 1 instance)
- Inset is fixed constant, not user-adjustable (use transform tools instead)
- Diamond grid stagger offset is fixed constant
- Vanilla and Shape popups include dropdown to switch variants
- Asset selection for right-click: TBD during implementation

OPEN QUESTIONS
--------------
- Should patterns be saved as presets?
- Should there be a preview before generation?
- How to handle pattern bounds relative to canvas size?
- Should generated instances be editable individually after generation?
- Support for layered patterns (pattern of patterns)?
