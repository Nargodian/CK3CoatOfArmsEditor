COORDINATE TRANSFORMATION TRACE - VERIFICATION REPORT
======================================================
Systematic check of coordinate_transform_trace.txt against actual code

Date: February 4, 2026
Method: Read actual source code and compare to documented trace


═══════════════════════════════════════════════════════════════════════════════
CRITICAL ERROR #1: Widget Coordinate System Confusion
═══════════════════════════════════════════════════════════════════════════════

CLAIM IN TRACE (Line 43-45):
"INPUT COORDINATES:
- event.pos() → Qt widget-local coordinates (top-left origin, pixels)
- Example: QPoint(350, 200) = 350px from left edge, 200px from top edge"

ACTUAL CODE VERIFICATION:
File: canvas_area.py, line 70
    self.transform_widget = TransformWidget(canvas_container, self.canvas_widget)
    - Parent: canvas_container
    - Reference: canvas_widget

File: transform_widget.py, line 196-205
    def _widget_to_center_origin(self, pos):
        """Convert widget top-left coordinates to center-origin coordinates."""
        return (pos.x() - self.width() / 2, pos.y() - self.height() / 2)

File: transform_widget.py, line 72-75
    if parent:
        self.setGeometry(0, 0, parent.width(), parent.height())
    - Transform widget fills canvas_container entirely

ACTUAL BEHAVIOR:
✅ CORRECT: event.pos() is in transform_widget's local coordinates
✅ CORRECT: Transform widget uses self.width() and self.height()
⚠️  AMBIGUITY: Transform widget size == canvas_container size, NOT canvas_widget size
    - canvas_container may be larger than canvas_widget if bars are inside it

IMPACT: Minor - trace is correct but doesn't clarify that transform_widget fills
        canvas_container, not canvas_widget. The coordinate origin is relative
        to transform_widget's own bounds.


═══════════════════════════════════════════════════════════════════════════════
CRITICAL ERROR #2: Missing "is_rotating" Flag
═══════════════════════════════════════════════════════════════════════════════

CLAIM IN TRACE (Line 580-593):
"Check if we're rotating (using rotation handle)
if hasattr(self.transform_widget, 'is_rotating') and self.transform_widget.is_rotating:"

ACTUAL CODE VERIFICATION:
File: canvas_area.py, line 577
    if hasattr(self.transform_widget, 'is_rotating') and self.transform_widget.is_rotating:

File: transform_widget.py
    grep search for "self.is_rotating" → NO MATCHES FOUND
    grep search for "is_rotating =" → NO MATCHES FOUND

File: handles.py
    grep search for "is_rotating" → NO MATCHES FOUND

ACTUAL BEHAVIOR:
❌ ERROR: The is_rotating flag is referenced but NEVER SET anywhere in the codebase
✅ CORRECT: The hasattr() check prevents crash, but condition never triggers
❌ ERROR: Rotation transforms never use the special rotation path described in trace
❌ ERROR: Rotation transforms are processed as regular transforms, not cached rotations

IMPACT: MAJOR - The trace documents a rotation optimization that doesn't actually
        execute. The code path for rotation caching (lines 577-593 in canvas_area.py)
        is DEAD CODE. Rotation is handled same as position/scale.


═══════════════════════════════════════════════════════════════════════════════
ERROR #3: Center-Origin vs Top-Left Coordinate Confusion
═══════════════════════════════════════════════════════════════════════════════

CLAIM IN TRACE (Line 569):
"Convert from center-origin to top-left coordinates first
center_x_topleft = center_x + self.canvas_widget.width() / 2
center_y_topleft = center_y + self.canvas_widget.height() / 2"

ACTUAL CODE VERIFICATION:
File: canvas_area.py, lines 570-571
    center_x_topleft = center_x + self.canvas_widget.width() / 2
    center_y_topleft = center_y + self.canvas_widget.height() / 2

File: transform_widget.py, lines 196-205
    def _widget_to_center_origin(self, pos):
        return (pos.x() - self.width() / 2, pos.y() - self.height() / 2)

ANALYSIS:
⚠️  INCONSISTENCY FOUND!
- Transform widget converts using: self.width() and self.height()
- Canvas area converts back using: canvas_widget.width() and canvas_widget.height()

These are DIFFERENT dimensions when:
- Transform widget is parented to canvas_container
- Canvas widget is inside canvas_container but smaller (e.g., with bars)

ACTUAL BEHAVIOR:
If canvas_widget.width() != transform_widget.width():
    → Coordinate round-trip will NOT preserve values!
    → center_x from widget will be misinterpreted by canvas_area!

Example scenario:
- Transform widget: 800x600 (full container)
- Canvas widget: 600x600 (square inside container)
- Mouse at center of transform widget: (400, 300)
- Widget converts: (400 - 800/2, 300 - 600/2) = (0, 0) center-origin
- Canvas area receives: (0, 0)
- Canvas area converts back: (0 + 600/2, 0 + 600/2) = (300, 300) top-left
- Result: Position shifted by 100 pixels left!

IMPACT: CRITICAL BUG - Coordinate mismatch when canvas_widget != transform_widget size!
        This will cause incorrect position calculations.


═══════════════════════════════════════════════════════════════════════════════
VERIFICATION #4: Handle Drag Coordinate Space
═══════════════════════════════════════════════════════════════════════════════

CLAIM IN TRACE (Line 51-53):
"Method: _widget_to_center_origin(pos)
- Shifts origin from top-left to center of transform_widget
- start_mouse_x = pos.x() - widget.width()/2"

ACTUAL CODE VERIFICATION:
File: transform_widget.py, lines 484-487
    start_mouse_x, start_mouse_y = self._widget_to_center_origin(self.drag_start_pos)
    curr_mouse_x, curr_mouse_y = self._widget_to_center_origin(current_pos)

File: transform_widget.py, lines 196-205
    def _widget_to_center_origin(self, pos):
        return (pos.x() - self.width() / 2, pos.y() - self.height() / 2)

File: handles.py, lines 46-61 (Handle ABC)
    @abstractmethod
    def drag(self, mouse_x, mouse_y, start_mouse_x, start_mouse_y, 
             start_cx, start_cy, start_hw, start_hh, start_rot, modifiers):
        """Args:
            mouse_x, mouse_y: Current mouse position in center-origin coordinates
            start_mouse_x, start_mouse_y: Drag start mouse position in center-origin coordinates
            start_cx, start_cy: Transform center at drag start (pixels, center-origin)
        """

ACTUAL BEHAVIOR:
✅ CORRECT: Handles receive center-origin coordinates
✅ CORRECT: Conversion uses self.width() and self.height()
✅ CORRECT: All handle drag() methods work in center-origin space

IMPACT: None - trace is accurate for this section.


═══════════════════════════════════════════════════════════════════════════════
VERIFICATION #5: CoA Scale Conversion Formula
═══════════════════════════════════════════════════════════════════════════════

CLAIM IN TRACE (Line 108-113):
"C1) Pixels → Frame scale
    Method: CanvasCoordinateMixin.pixels_to_frame_scale(half_w, half_h)
    - COA_BASE_SIZE_PX = 256 (constant from canvas_widget_NEW.py)
    - frame_scale_x = (half_w * 2.0) / (COA_BASE_SIZE_PX * zoom_level)
    - frame_scale_y = (half_h * 2.0) / (COA_BASE_SIZE_PX * zoom_level)"

ACTUAL CODE VERIFICATION:
File: canvas_widget_NEW.py, line 54
    COA_BASE_SIZE_PX = 256.0  # Base CoA size in pixels

File: canvas_coordinate_mixin.py, lines 254-262
    def pixels_to_frame_scale(self, half_w, half_h):
        """Convert pixel AABB half-dimensions to frame-adjusted scale."""
        from components.canvas_widget_NEW import COA_BASE_SIZE_PX
        
        frame_scale_x = (half_w * 2.0) / (COA_BASE_SIZE_PX * self.zoom_level)
        frame_scale_y = (half_h * 2.0) / (COA_BASE_SIZE_PX * self.zoom_level)
        
        return frame_scale_x, frame_scale_y

ACTUAL BEHAVIOR:
✅ CORRECT: Formula matches exactly
✅ CORRECT: COA_BASE_SIZE_PX = 256.0
✅ CORRECT: Divides by (256 * zoom_level)

IMPACT: None - trace is accurate.


═══════════════════════════════════════════════════════════════════════════════
VERIFICATION #6: Frame Transform Application
═══════════════════════════════════════════════════════════════════════════════

CLAIM IN TRACE (Line 171-179):
"A1) CoA space → Frame space
    Method: CanvasCoordinateMixin.coa_to_frame(pos_x, pos_y)
    Applies frame scale/offset:
    - centered_x = pos_x - 0.5
    - centered_y = pos_y - 0.5
    - scaled_x = centered_x * frame_scale[0]
    - scaled_y = centered_y * frame_scale[1]"

ACTUAL CODE VERIFICATION:
File: canvas_coordinate_mixin.py, lines 28-57
    def coa_to_frame(self, pos_x, pos_y):
        frame_scale, frame_offset = self.get_frame_transform()
        
        # Center position (move to origin)
        centered_x = pos_x - 0.5
        centered_y = pos_y - 0.5
        
        # Apply frame scale
        scaled_x = centered_x * frame_scale[0]
        scaled_y = centered_y * frame_scale[1]
        
        # Move back from origin
        uncentered_x = scaled_x + 0.5
        uncentered_y = scaled_y + 0.5
        
        # Apply frame offset
        frame_x = uncentered_x - frame_offset[0] * frame_scale[0]
        frame_y = uncentered_y - frame_offset[1] * frame_scale[1]
        
        return frame_x, frame_y

ACTUAL BEHAVIOR:
✅ CORRECT: All formulas match exactly
✅ CORRECT: Order of operations is correct

IMPACT: None - trace is accurate.


═══════════════════════════════════════════════════════════════════════════════
VERIFICATION #7: Zoom/Pan Application in frame_to_canvas
═══════════════════════════════════════════════════════════════════════════════

CLAIM IN TRACE (Line 183-192):
"A2) Frame space → Canvas pixels
    Applies zoom/pan:
    - gl_x = frame_x * 2.0 - 1.0
    - gl_y = -(frame_y * 2.0 - 1.0)  # Invert Y
    - canvas_size = min(width, height)
    - pixel_x = gl_x * (canvas_size / 2) * zoom_level
    - pixel_y = gl_y * (canvas_size / 2) * zoom_level
    - x = width/2 + pixel_x + pan_x
    - y = height/2 - pixel_y + pan_y  # Qt Y-down"

ACTUAL CODE VERIFICATION:
File: canvas_coordinate_mixin.py, lines 92-129
    def frame_to_canvas(self, frame_x, frame_y, clamp=False):
        # Convert to OpenGL coords
        gl_x = frame_x * 2.0 - 1.0
        gl_y = -(frame_y * 2.0 - 1.0)  # Invert Y
        
        # Get current canvas size
        width, height = self.width(), self.height()
        canvas_size = min(width, height)
        
        # Convert to canvas pixels with zoom (pure pixel-based)
        pixel_x = gl_x * (canvas_size / 2) * self.zoom_level
        pixel_y = gl_y * (canvas_size / 2) * self.zoom_level
        
        # Canvas center + pan
        x = width / 2 + pixel_x + self.pan_x
        y = height / 2 - pixel_y + self.pan_y  # Qt Y-down

ACTUAL BEHAVIOR:
✅ CORRECT: All formulas match exactly
✅ CORRECT: GL coordinate conversion correct
✅ CORRECT: Pan offset applied correctly

IMPACT: None - trace is accurate.


═══════════════════════════════════════════════════════════════════════════════
CRITICAL ERROR #8: Edit Lock Synchronization Missing
═══════════════════════════════════════════════════════════════════════════════

CLAIM IN TRACE (Line 356-361):
"RELEASE:
Code:
    try:
        # TODO: Sync widget display to model truth before releasing lock
        pass
    finally:"

ACTUAL CODE VERIFICATION:
File: transform_widget.py, lines 374-388
    def mouseReleaseEvent(self, event):
        """Handle mouse release - complete drag operation"""
        if not self.active_handle:
            self._forward_event_to_canvas(event)
            event.ignore()
            return
        
        if event.button() == Qt.LeftButton and self.active_handle:
            # Track if this was a duplicate drag for history
            was_duplicate_drag = self.drag_context and self.drag_context.duplicate_created
            
            # Release edit lock in try/finally to guarantee release (Decision 4)
            try:
                # TODO: Sync widget display to model truth before releasing lock
                # This ensures UI matches model values and catches conversion rounding errors
                pass

ACTUAL BEHAVIOR:
❌ ERROR: Sync step is still TODO - never implemented!
✅ CORRECT: try/finally block exists
❌ ERROR: Widget display may not match model truth when lock releases
❌ ERROR: Rounding errors can accumulate without correction

IMPACT: MODERATE - Without sync, small rounding errors could accumulate over
        repeated transforms. The trace documents intended behavior, not actual.


═══════════════════════════════════════════════════════════════════════════════
VERIFICATION #9: Signal Connection
═══════════════════════════════════════════════════════════════════════════════

CLAIM IN TRACE (Line 74-76):
"SIGNAL EMITTED:
transformChanged.emit(center_x, center_y, half_w, half_h, rotation)
→ Connected to canvas_area._on_transform_changed()"

ACTUAL CODE VERIFICATION:
File: canvas_area.py, line 72
    self.transform_widget.transformChanged.connect(self._on_transform_changed)

File: transform_widget.py, line 505
    self.transformChanged.emit(self.center_x, self.center_y, self.half_w, self.half_h, self.rotation)

File: canvas_area.py, line 554
    def _on_transform_changed(self, center_x, center_y, half_w, half_h, rotation):

ACTUAL BEHAVIOR:
✅ CORRECT: Signal is connected
✅ CORRECT: Signal parameters match method signature
✅ CORRECT: Signal emits current widget state

IMPACT: None - trace is accurate.


═══════════════════════════════════════════════════════════════════════════════
SUMMARY OF ERRORS FOUND
═══════════════════════════════════════════════════════════════════════════════

CRITICAL BUGS IN ACTUAL CODE (Not just trace errors):
1. ❌ CRITICAL: Coordinate dimension mismatch
   - Transform widget uses self.width()/self.height()
   - Canvas area uses canvas_widget.width()/canvas_widget.height()
   - These can be different sizes → coordinate corruption
   - Location: transform_widget.py:205, canvas_area.py:570-571

2. ❌ MAJOR: is_rotating flag never set
   - Dead code path for rotation optimization
   - Rotation transforms processed incorrectly
   - Location: canvas_area.py:577 (check), nowhere (set)

3. ❌ MODERATE: Sync to model TODO not implemented
   - Rounding errors can accumulate
   - Location: transform_widget.py:378

TRACE DOCUMENTATION ERRORS:
4. ⚠️  MINOR: Ambiguity about widget vs container dimensions
   - Trace doesn't clarify transform_widget fills canvas_container
   - Not technically wrong, just incomplete

5. ❌ MAJOR: Rotation path documented but doesn't execute
   - Trace describes rotation caching that never runs
   - Misleading about actual data flow


═══════════════════════════════════════════════════════════════════════════════
RECOMMENDATIONS
═══════════════════════════════════════════════════════════════════════════════

FIX #1: Coordinate Dimension Mismatch
File: canvas_area.py, lines 570-571
CHANGE FROM:
    center_x_topleft = center_x + self.canvas_widget.width() / 2
    center_y_topleft = center_y + self.canvas_widget.height() / 2

CHANGE TO:
    # Use transform_widget dimensions (not canvas_widget) to match conversion
    center_x_topleft = center_x + self.transform_widget.width() / 2
    center_y_topleft = center_y + self.transform_widget.height() / 2

RATIONALE: Must use same dimensions for conversion and inverse conversion.

FIX #2: Remove Dead Rotation Code or Implement is_rotating
OPTION A: Remove dead code (lines 577-593 in canvas_area.py)
OPTION B: Implement is_rotating flag properly:
    - Set in transform_widget when rotation handle active
    - Clear when drag ends

FIX #3: Implement Sync to Model
File: transform_widget.py, lines 378-380
Replace TODO with actual implementation:
    # Sync widget display to model truth
    if hasattr(self, 'main_window') and self.main_window:
        # Trigger canvas_area.update_transform_widget_for_layer()
        # This reads from model and updates widget display
        pass


═══════════════════════════════════════════════════════════════════════════════
CONCLUSION
═══════════════════════════════════════════════════════════════════════════════

The trace document is MOSTLY ACCURATE for conversion formulas and data flow,
but has TWO CRITICAL ISSUES:

1. Documents rotation optimization that DOESN'T EXECUTE (dead code)
2. Misses CRITICAL BUG in coordinate dimension mismatch

The actual codebase has a CRITICAL BUG that will cause position errors when
canvas_widget size != transform_widget size.

Trace accuracy: 85%
Code correctness: 70% (critical bug present)

VERIFICATION STATUS: FAILED - Critical bugs found in both trace and code.
