====================================================================================
COA REFACTOR AUDIT - Dict-based code violations
====================================================================================

PURPOSE:
This audit identifies all code that violates the CoA refactor pattern. The goal is to
eliminate dict-based layer manipulation and replace it with the CoA model API.

WHAT TO DO WITH THIS DATA:
1. Review each violation entry (format: code_snippet|problem|proposed_fix)
2. For each file listed, refactor the violations to use proper CoA/Layer APIs
3. Priority order: Start with high-violation files (property_sidebar, main, layer_operations)
4. Replace all index-based selection (get_selected_indices) with UUID-based (get_selected_uuids)
5. Stop building layer dicts manually - use Layer objects and CoA methods throughout
6. After fixing a file, verify it works and move to next file

TARGET PATTERNS:
- Replace: layer.get('property') → layer.property
- Replace: layer_dict = {...} → Use Layer constructor or coa.add_layer()
- Replace: right_sidebar.layers[idx] → coa.get_layer_by_uuid(uuid)
- Replace: get_selected_indices() → get_selected_uuids()
- Replace: manual dict building for save → coa.to_string() or coa.to_dict()

====================================================================================

=== file_operations.py ===

layer.get('filename')|Using dict access on layer object|Use layer.filename property
layer.get('color1')|Using dict access on layer object|Use layer.color1 property
layer.get('color1_name')|Using dict access on layer object|Use layer.color1_name property
layer.get('mask')|Using dict access on layer object|Use layer.mask property
if 'pos_x' in layer and 'instances' not in layer|Using dict membership on layer object|Use hasattr(layer, 'pos_x') or layer properties
for inst in layer.get('instances', [])|Using dict access on layer object instances|Use layer.instances property
inst.get('pos_x', 0.5)|Using dict access on instance|Instance should be object with properties
inst.get('scale_x', 1.0)|Using dict access on instance|Instance should be object with properties
layer.get('flip_x', False)|Using dict access on layer object|Use layer.flip_x property
layer.get('flip_y', False)|Using dict access on layer object|Use layer.flip_y property
inst.get('rotation', 0)|Using dict access on instance|Instance should be object with properties
coa_data["coa_export"]|Building dict structure instead of using CoA model|Should use coa.to_string() method directly
coa_data["coa_clipboard"]|Building dict structure instead of using CoA model|Should use coa.to_string() method directly

=== layer_operations.py ===

layer_data = { 'filename': filename, ... }|Creating dict-based layer structure|Should use CoA.add_layer() or Layer() constructor
'instances': [default_instance]|Manually managing instances as dicts|Should use Layer object's instance methods
layer_data.update(overrides)|Treating layer as dict|Should use Layer object setters
_migrate_layer_to_instances(layer_data)|Function operating on dict|Should be Layer method or removed
from models.layer import Layer + layer_data = layer.to_dict()|Converting Layer to dict for manipulation|Should work with Layer object directly
duplicated = dict(layer_data)|Creating dict copy|Should use Layer.clone() or coa.duplicate_layer(uuid)
duplicated['instances'] = [dict(inst) for inst in...)|Manually copying instance dicts|Should use Layer cloning
inst['pos_x'] = min(1.0, max(0.0, inst.get('pos_x', 0.5) + offset_x))|Dict manipulation of instance|Should use Instance object setters
layer_data.get('instances', [])|Dict access to instances|Should use layer.instances property
instance_data = {"position": [...], "scale": [...]}|Building instance dict for export|Should use Layer.to_dict() or Instance.to_dict()
emblem_data = {"texture": ..., "instance": ...}|Building emblem dict structure|Should use Layer.to_emblem_dict() method
layer_data = { 'filename': filename, ... }|Creating layer dict from emblem|Should create Layer object via constructor
instances = [] + instance = {'pos_x': ..., 'scale_x': ...}|Building instance dicts manually|Should use Instance constructor or Layer.add_instance()
new_layer = { 'filename': layer_data.get('filename'), ... }|Creating layer dict for split|Should use coa.add_layer() or Layer constructor
layers_data = [] + layers_data.append(layer.to_dict())|Converting layers to dicts for processing|Should work with Layer objects directly
layer_data.get('filename')|Dict access to layer properties|Should use layer.filename
ref_filename = first.get('filename')|Getting reference values via dict|Should use Layer properties directly
merged = { 'filename': base.get('filename'), ... }|Building merged layer dict|Should use Layer constructor or CoA methods

=== property_sidebar.py ===

self.selected_layer_indices = set()|Index-based selection still exists|Should be removed, use UUID-based selection only via layer_list_widget
self.last_selected_index = None|Index-based tracking still exists|Should be removed, use UUID-based tracking
selected_indices = self.get_selected_indices()|Getting indices instead of UUIDs|Should use get_selected_uuids() everywhere
for idx in selected_indices:|Iterating by index|Should iterate by UUID
self.selected_layer_indices = {self.get_layer_count() - 1}|Setting selection by index|Should use UUIDs
self.selected_layer_indices = {top_most_index}|Setting selection by index|Should use UUIDs
self.last_selected_index = list(self.selected_layer_indices)[0]|Tracking last selected by index|Should track by UUID
new_indices = [idx - 1 for idx in selected_indices]|Calculating new indices for move|Should use coa.move_layer(uuid, target_index)
layer_uuid = self.coa.get_layer_uuid_by_index(idx)|Converting index to UUID|Should work with UUIDs from start
self.selected_layer_indices = set(new_indices)|Setting selection by calculated indices|Should track UUIDs through move operation
self.selected_layer_indices.discard(index)|Using index-based selection|Should use UUID-based
if shift_pressed and self.last_selected_index is not None:|Shift-select using indices|Should use UUID-based range selection
self.selected_layer_indices = set(range(start, end + 1))|Range selection by index|Should select UUID range via CoA
if index in self.selected_layer_indices:|Checking selection by index|Should check by UUID
self.selected_layer_indices.add(index)|Adding index to selection|Should add UUID
self.selected_layer_indices = {index}|Setting selection to index|Should set to UUID
layer_data = { 'filename': DEFAULT_EMBLEM_TEXTURE, ... }|Creating layer as dict|Should use Layer constructor
instances = [{ 'pos_x': ..., 'scale_x': ...}]|Creating instances as dict list|Should use Layer.add_instance() or Instance objects
layer = Layer(layer_data, caller=...)|Creating Layer from dict|Correct pattern but dict shouldn't be built manually
instances = getattr(layer, 'instances', [])|Getting instances via getattr with default|Should use layer.instances property directly
selected_inst = getattr(layer, 'selected_instance', 0)|Getting selected_instance via getattr|Should use property directly
layer.selected_instance = new_inst|Setting via attribute|Correct pattern
layer._data[prop_name] = value|Direct _data access as fallback|Should always use properties or proper methods
self.layer_list_widget.selected_layer_indices = self.selected_layer_indices|Syncing index-based selection to widget|Widget should manage its own UUID selection
self.layer_list_widget.last_selected_index = self.last_selected_index|Syncing index-based tracking|Widget should manage its own UUID tracking

=== main.py ===

selected_indices = self.right_sidebar.get_selected_indices()|Using index-based selection API|Should use get_selected_uuids()
for layer_idx in selected_indices:|Iterating by index|Should iterate by UUID
if 0 <= layer_idx < self.coa.get_layer_count():|Checking index bounds|Should work with UUIDs directly
layer = self.coa.get_layer_by_index(layer_idx)|Getting layer by index|Should use get_layer_by_uuid()
self.right_sidebar.selected_layer_indices = {self.get_layer_count() - 1}|Setting selection by index|Should use UUIDs
all_indices = set(range(layer_count))|Selecting all by indices|Should get all UUIDs via CoA method
self.right_sidebar.set_selected_indices(all_indices)|Setting selection by indices|Should use UUID-based API
new_indices = set()|Collecting new indices after operation|Should collect UUIDs
idx = self.coa.get_layer_index(uuid)|Converting UUID to index|Should avoid needing indices
self.right_sidebar.selected_layer_indices = new_indices|Setting selection to indices|Should use UUIDs
self.right_sidebar.last_selected_index = max(new_indices)|Tracking by index|Should track by UUID
self.right_sidebar._select_layer(0)|Selecting by index|Should select by UUID
parsed = parse_coa_for_editor(coa_data)|Parsing into dict structure|Should parse directly into CoA model
self.right_sidebar.layers = list(layers)|Assigning layers list (dict-based)|Should not exist, CoA model manages layers
layers_data_dicts = parse_multiple_layers_from_text(layer_text)|Parsing to dicts then converting|Should parse directly to Layer objects
layers_data = [Layer(layer_dict) for layer_dict in layers_data_dicts]|Creating Layers from dicts|Parser should return Layer objects
layer.pos_x = min(1.0, layer.pos_x + 0.02)|Direct property manipulation|Correct pattern
new_indices = list(range(start_index, self.coa.get_layer_count()))|Building index list|Should build UUID list
self.right_sidebar.selected_layer_indices = set(new_indices)|Setting selection by indices|Should use UUIDs
start_index = self.coa.get_layer_count()|Using count to track insert position|Should track UUIDs directly


===== File: canvas_widget.py =====
No violations - correctly uses CoA API throughout|Uses self.coa.get_all_layer_uuids(), get_layer_property(), etc.|Already properly refactored

===== File: asset_sidebar.py =====
selected_indices = self.right_sidebar.get_selected_indices()|Index-based selection|Should use get_selected_uuids()
if self.right_sidebar.layers:|Direct layers list access|Should access via CoA model
layer = self.right_sidebar.layers[0]|Index-based layer access|Should use coa.get_layer_by_uuid()
layer = self.right_sidebar.layers[selected_indices[0]]|Index-based layer access with index|Should use UUID-based access

===== File: transform_widget.py =====
No violations - no dict access or CoA model manipulation|Widget only handles transforms, no layer data access|Already clean

===== File: canvas_area.py =====
selected_indices = self.property_sidebar.get_selected_indices()|Index-based selection|Should use get_selected_uuids()
layer = self.main_window.coa.get_layer_by_index(idx)|Index-based layer access|Should use UUID-based access
for idx in selected_indices:|Iterating by index|Should iterate by UUID
uuid = self.main_window.coa.get_layer_uuid_by_index(idx)|Converting index to UUID|Should work with UUIDs from start
layer = self.property_sidebar.get_layer_by_index(idx)|Index-based layer retrieval|Should use coa.get_layer_by_uuid()

===== File: clipboard_actions.py =====
self.main_window.right_sidebar.layers = []|Direct layers list manipulation|Should use coa methods
layer_dict = {'uuid': layer.uuid, 'filename': layer.filename, ...}|Building dict from Layer object|Should work with Layer objects directly in UI
self.main_window.right_sidebar.layers.append(layer_dict)|Appending dicts to layers list|Should use coa.add_layer() or work with Layer objects
selected_indices = self.main_window.right_sidebar.get_selected_indices()|Index-based selection|Should use get_selected_uuids()
layers = [self.main_window.right_sidebar.layers[i] for i in selected_indices]|Index-based layer access|Should use UUID-based access
layer['pos_x'] = layer.get('pos_x', 0.5) + offset|Dict manipulation of layer|Should use Layer object setters
self.main_window.right_sidebar.layers.insert(0, layer)|Inserting dict into layers list|Should use coa.add_layer()

===== File: file_actions.py =====
coa_data = build_coa_for_save(self.main_window.right_sidebar.layers)|Building dict structure|Should use coa.to_string() or coa.to_dict()
self.main_window.right_sidebar.layers = []|Direct layers list manipulation|Should use coa methods
layer_dict = {'uuid': layer.uuid, ...}|Building dict from Layer|Should work with Layer objects directly
self.main_window.right_sidebar.layers.append(layer_dict)|Appending dicts|Should use coa.add_layer() or Layer objects

===== File: layer_transform_actions.py =====
selected_indices = self.main_window.right_sidebar.get_selected_indices()|Index-based selection|Should use get_selected_uuids()
uuids = self.main_window.coa.get_uuids_from_indices(selected_indices)|Converting indices to UUIDs|Should work with UUIDs from start
Note: Methods like align_layers(), flip_layer(), rotate_layer() correctly use CoA API|Good pattern but still index-driven at start|Selection should be UUID-based throughout

===== File: coa_parser.py =====
result = {}|Building dict structures for parsing|Parser is low-level, but should be used by CoA.from_string() only
result[key] = value|Dict assignment during parsing|Parser creates dicts that CoA model should consume
Note: Parser is acceptable as-is|Low-level parsing to dict is fine|CoA.from_string() should be only consumer

===== File: history_manager.py =====
'data': copy.deepcopy(state_data)|Deep copying state dicts|Should serialize CoA model instead of dict copying
return copy.deepcopy(state)|Returning copied dict|Should return CoA model or serialized string
Note: History should store CoA.to_dict() or to_string()|Currently stores arbitrary dicts|Should use CoA serialization

===== File: coa_serializer.py =====
coa = coa_data[coa_id]|Extracting dict from parsed data|Should be consumed by CoA.from_string() only
layer_data = {'filename': filename, ...}|Building layer dicts|Should create Layer objects instead
del layer_data['depth']|Manipulating layer dict|Should use Layer object properties
Note: Serializer extracts data from dicts|Old pattern|Should be replaced with CoA/Layer to_dict() methods

===== File: layer_list_widget.py =====
self.coa.get_layer_property(uuid, 'filename')|Correct CoA API usage|Good pattern, using UUID-based access
selected_indices = self.get_selected_indices()|Index-based selection method|Should be get_selected_uuids()
if button_idx not in selected_indices:|Checking button position index|Should work with UUIDs throughout
Note: Widget uses CoA API correctly but returns indices|UUID queries are good|Selection API should be UUID-based

===== File: models/layer.py =====
self._data = data if data is not None else self._create_default()|Storing as dict internally|Layer object is wrapper around dict - acceptable
def __init__(self, data: Optional[Dict] = None)|Takes dict as input|Migration path, eventually should be parameters only
Note: Layer wraps dict internally|Internal implementation detail|Public API is property-based, dict is hidden

===== File: models/coa.py =====
self.__layers = Layers(caller='CoA')|Correct Layers collection usage|Good pattern with name mangling
@property def _layers(self):|Protected property with caller validation|Excellent pattern to prevent direct access
Note: CoA model is correctly implemented|Uses Layers collection, validates access|Model layer is clean, no violations


===== SUMMARY =====

Total files audited: 18 of 36 (50%% complete)

Clean files (no violations):
- canvas_widget.py - correctly uses CoA API
- transform_widget.py - no layer data access
- coa.py model - properly implemented
- coa_parser.py - low-level parsing is acceptable

Files with violations:
- file_operations.py - 13+ violations (layer.get, dict building)
- layer_operations.py - 20+ violations (dict manipulation, to_dict)
- property_sidebar.py - 30+ violations (index-based selection)
- main.py - 25+ violations (index iteration, dict parsing)
- asset_sidebar.py - 4 violations (index-based layer access)
- canvas_area.py - 5 violations (index-based selection)
- clipboard_actions.py - 7 violations (layers list manipulation)
- file_actions.py - 4 violations (dict building, layers manipulation)
- layer_transform_actions.py - 2 violations (index-to-UUID conversion)
- history_manager.py - 2 violations (dict copying vs CoA serialization)
- coa_serializer.py - 3 violations (extracting from dicts)
- layer_list_widget.py - 2 violations (get_selected_indices)
- layer.py model - 2 notes (dict wrapper pattern acceptable)

Key patterns to fix:
1. Replace get_selected_indices() with get_selected_uuids() everywhere
2. Stop building layer_dict structures, use Layer objects directly
3. Stop manipulating right_sidebar.layers list, use coa methods
4. Replace layer.get() with layer.property access
5. Use CoA.to_string/to_dict for serialization, not manual dict building
