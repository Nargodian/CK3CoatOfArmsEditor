================================================================================
MULTI-LAYER SELECTION FEASIBILITY STUDY
CK3 Coat of Arms Editor
Date: January 24, 2026
================================================================================

EXECUTIVE SUMMARY
-----------------
Adding multi-layer selection to the CK3 Coat of Arms Editor is feasible with
moderate complexity. The current architecture is designed around single-layer
selection but can be extended to support multiple layers. Key challenges
involve handling multiple transform widgets, property editing, and ensuring
consistent history/undo behavior.

Estimated Development Time: 8-12 hours
Complexity: Medium
Risk Level: Low-Medium


CURRENT SYSTEM ANALYSIS
------------------------

1. SELECTION SYSTEM
   - Location: property_sidebar.py
   - Current: Single integer `selected_layer_index` (line 16)
   - Behavior: Click to select, click again to deselect
   - Selection updates: _select_layer(), _deselect_layer()
   - Layer buttons are checkable QPushButtons with visual feedback

2. TRANSFORM WIDGET
   - Location: canvas_area.py, transform_widget.py
   - Current: Single TransformWidget overlays the canvas
   - Handles: 4 corner, 4 edge, 1 center (move), 1 rotation
   - Updates when layer selection changes
   - Emits signals on transform changes and drag end (for history)

3. PROPERTY SIDEBAR
   - Location: property_sidebar.py
   - Properties tab shows selected layer's properties
   - Disabled when no layer selected
   - Updates real-time as transform widget is manipulated
   - Sliders for: position X/Y, scale X/Y, rotation, texture scale, color

4. LAYER OPERATIONS
   - Add Layer: Adds to end, auto-selects new layer
   - Delete Layer: Removes and selects previous layer
   - Move Up/Down: Swaps layers in list, maintains selection
   - Duplicate: Creates copy of layer with offset position
   - Drag Reorder: Mouse drag to reorder layers

5. HISTORY SYSTEM
   - Location: utils/history_manager.py
   - Tracks full state snapshots (deep copy)
   - Operations trigger: _save_state() in main.py
   - Supports undo/redo with state restoration


IMPLEMENTATION REQUIREMENTS
----------------------------

1. DATA STRUCTURE CHANGES
   ✓ Change `selected_layer_index` (int) → `selected_layer_indices` (list/set)
   ✓ Update all references throughout codebase
   ✓ Maintain selection order for operations that need it

2. SELECTION UI CHANGES
   ✓ Support Ctrl+Click for toggle selection
   ✓ Support Shift+Click for range selection
   ✓ Visual indication for multiple selected layers
   ✓ Update layer button checkable state for multi-select
   ✓ Clear selection when clicking canvas background

3. TRANSFORM WIDGET CHANGES
   ✓ Show single widget representing selection bounds/center
   ✓ Apply transforms to all selected layers simultaneously
   ✓ Maintain relative positions/scales during group transforms
   ✓ Handle rotation pivot point for group rotation
   ✓ Update widget when any selected layer changes
   ⚠ CRITICAL: Handle CK3's rotation-then-scale transform order
   ⚠ CRITICAL: Scale values apply to screen axes, not object axes

4. PROPERTY PANEL CHANGES
   ✓ Show properties for multi-selection scenarios
   ✓ Display common values or "Mixed" indicators
   ✓ Apply property changes to all selected layers
   ✓ Handle cases where properties differ between layers

5. LAYER OPERATIONS CHANGES
   ✓ Delete: Remove all selected layers
   ✓ Duplicate: Duplicate all selected layers
   ✓ Move Up/Down: Move entire selection group
   ✓ Reorder: Handle drag with multiple selected items
   ✓ Copy/Paste: Support multi-layer clipboard operations

6. HISTORY SYSTEM CHANGES
   ✓ No changes needed (already handles full state snapshots)
   ✓ Ensure all multi-layer operations save state correctly

7. KEYBOARD SHORTCUTS
   ✓ Ctrl+A: Select all layers
   ✓ Ctrl+D: Deselect all layers
   ✓ Delete key: Delete selected layers
   ✓ Ctrl+C/V: Copy/paste selected layers
   ✓ Ctrl+D: Duplicate selected layers (or use Ctrl+J)


FILES REQUIRING MODIFICATION
-----------------------------

PRIMARY FILES:
1. src/components/property_sidebar.py
   - Change selected_layer_index to selected_layer_indices
   - Update _select_layer() for Ctrl/Shift modifiers
   - Modify _update_layer_selection() for multiple buttons
   - Update _deselect_layer() to clear all selections
   - Modify property loading/updating for multi-select
   - Update all layer operations (delete, move, duplicate)

2. src/components/canvas_area.py
   - Update update_transform_widget_for_layer() to accept list
   - Calculate group bounds for multiple layers
   - Update transform callbacks to apply to all selected layers

3. src/components/transform_widget.py
   - Modify to represent group transform state
   - Calculate bounding box for multiple items
   - Apply relative transforms to maintain group coherence

4. src/main.py
   - Update _apply_state() for multi-selection restoration
   - Modify copy_layer() to handle multiple layers
   - Update any references to selected_layer_index

SECONDARY FILES:
5. src/components/canvas_widget.py
   - No changes needed (already handles layer list)

6. src/utils/history_manager.py
   - No changes needed (already handles arbitrary state)


DESIGN DECISIONS REQUIRED
--------------------------

CRITICAL DECISIONS:

1. TRANSFORM WIDGET BEHAVIOR
   Question: How should the transform widget represent multiple selected layers?
   
   Option A: Show bounding box of all selected layers
   - Pros: Clear visual representation of group
   - Cons: May not match any individual layer's transform
   
   Option B: Show widget for "primary" selected layer
   - Pros: Matches one layer exactly
   - Cons: Not clear which layer is primary, confusing for users
   
   Option C: Show center point only with special indicator
   - Pros: Simple, unambiguous
   - Cons: Less intuitive for users
   
   RECOMMENDATION: Option A (bounding box)
   - Calculate min/max X/Y from all selected layer positions
   - Display handles at group bounds
   - Transform applies proportionally to each layer


2. PROPERTY PANEL BEHAVIOR
   Question: How should properties display when multiple layers selected?
   
   Option A: Show "Mixed" for different values, common value if same
   - Pros: Standard UI pattern, informative
   - Cons: More complex implementation
   
   Option B: Show first selected layer's properties
   - Pros: Simple implementation
   - Cons: Misleading to user
   
   Option C: Show disabled/blank properties
   - Pros: Prevents confusion
   - Cons: Can't edit multiple layers at once (major limitation)
   
   RECOMMENDATION: Option A (Mixed values)
   - Display actual value if all selected layers have same value
   - Display "—" or "Mixed" if values differ
   - Changing a mixed value applies to all selected layers
   - Add clear label: "Multiple Layers Selected (X layers)"


3. TRANSFORM APPLICATION
   Question: How should transforms apply to multiple selected layers?
   
   Option A: Absolute - all layers get same transform value
   - Pros: Simple to implement
   - Cons: Layers collapse to same position (useless)
   
   Option B: Relative - transforms applied proportionally
   - Pros: Maintains relative spacing/sizing
   - Cons: More complex math
   
   Option C: Pivot-based - transform around group center
   - Pros: Most intuitive for users (like Photoshop)
   - Cons: Most complex implementation, requires handling CK3's unusual transform order
   
   RECOMMENDATION: Option C (Pivot-based with relative transforms)
   - Calculate group center point
   - For position: Move all layers by same delta
   - For scale: Scale positions and sizes relative to group center
   - For rotation: Rotate all layers around group center
   - Maintain each layer's individual rotation + add group rotation
   
   ⚠ CRITICAL CK3 TRANSFORM CONSTRAINT:
   CK3 applies transforms as: ROTATION → SCALE → POSITION
   - Scale is ALWAYS applied to screen X/Y axes, NOT object's local axes
   - This means: rotation=90° + scale={2.0, 1.0} creates a HORIZONTAL rectangle
   - Multi-layer scaling works predictably because both the transform widget
     and CK3's scale system operate in screen-space coordinates
   - When scaling the group AABB, all layers scale in screen-space regardless
     of their individual rotation values - this is intuitive and consistent


4. ROTATION BEHAVIOR
   Question: How does group rotation work?
   
   Option A: Rotate each layer's position around group center only
   - Pros: Simpler, avoids compounding rotation issues
   - Cons: Individual layer orientations don't change
   
   Option B: Rotate positions AND add to each layer's rotation
   - Pros: More natural behavior, layers rotate themselves too
   - Cons: More complex, changes individual layer rotations permanently
   
   DECISION: Option A (rotate positions only)
   - Rotate layer positions around group pivot point
   - Do NOT modify individual layer rotation values
   - Simpler to implement and reason about
   - Avoids compounding rotation values
   - Each layer maintains its individual orientation while moving in circular path
   - If user wants to rotate layers themselves, select individually


5. LAYER LIST INTERACTION
   Question: How to handle multi-select in layer list?
   
   Option A: Standard Ctrl+Click, Shift+Click
   - Ctrl+Click: Toggle individual layer
   - Shift+Click: Select range from last selection
   
   Option B: Simple toggle only
   - Click: Toggle layer in selection
   - No range selection
   
   RECOMMENDATION: Option A (Standard multi-select)
   - Implements expected desktop UI patterns
   - Ctrl+Click: Add/remove from selection
   - Shift+Click: Select range
   - Click (no modifier): Clear selection and select clicked
   - Click already-selected when multi-selected: Make it sole selection


6. DELETE BEHAVIOR
   Question: When deleting multiple layers, what should be selected after?
   
   Option A: Select nothing (clear selection)
   - Pros: Simple, safe
   - Cons: User loses context
   
   Option B: Select layer below deleted range
   - Pros: Keeps user in context
   - Cons: May not exist
   
   RECOMMENDATION: Option B with fallback to A
   - Select the layer that would be at the top-most deleted position
   - If no layers remain, clear selection


7. COPY/PASTE BEHAVIOR
   Question: Should copy/paste support multiple layers?
   
   Option A: Yes, serialize multiple colored_emblem blocks
   - Pros: Powerful feature
   - Cons: More complex serialization
   
   Option B: No, only copy if single layer selected
   - Pros: Simple
   - Cons: Limiting
   
   RECOMMENDATION: Option A
   - Copy all selected layers to clipboard
   - Paste creates all layers at once
   - Paste adds to current layers (doesn't replace)


8. DUPLICATE POSITION OFFSET
   Question: Where should duplicated multi-selection appear?
   
   Option A: Offset each layer by same amount (10 units right, 10 down)
   - Pros: Maintains relative positions
   - Cons: May go off screen
   
   Option B: Don't offset, place exactly on top
   - Pros: Predictable
   - Cons: Can't see what happened
   
   RECOMMENDATION: Option A
   - Apply small offset (0.02 in normalized coords) to all layers
   - Select newly duplicated layers after creation


9. NON-UNIFORM SCALING
   Question: Should non-uniform scaling work on multiple layers?
   
   Option A: Yes, scale all layers' X or Y proportionally
   - Pros: More powerful, full control
   - Cons: More complex implementation
   
   Option B: Disable side handles, only corner handles (uniform scale)
   - Pros: Simpler implementation
   - Cons: Less flexible, limits user control
   
   ✓ KEY INSIGHT: SCREEN-SPACE CONSISTENCY
   Non-uniform scaling DOES work predictably for multi-selection because:
   1. Transform widget represents screen-space AABB (axis-aligned bounding box)
   2. CK3's scale values are ALSO screen-space (applied to X/Y axes)
   3. Both are aligned to the same coordinate system!
   
   When scaling AABB horizontally (via edge handle):
   - Scale all layer positions X-coordinate relative to group center
   - Scale all layer scale_x values by same factor
   - Both operations use screen-space X axis
   - Result is consistent and predictable
   
   Example:
   - Layer A at rotation=0°, Layer B at rotation=90°
   - Stretch group AABB horizontally by 2x
   - Both layers' X positions scale by 2x (repositioning)
   - Both layers' scale_x multiply by 2x (screen-space stretch)
   - Visually consistent: group stretches horizontally in screen space
   
   DECISION: Option A (enable non-uniform scaling)
   - Show edge handles for multi-selection
   - Scale operates on screen-space AABB
   - Scale positions and scale values using same screen-space axes
   - This aligns with CK3's transform system rather than fighting it
   - Simpler mental model: "stretch the bounding box"


MINOR DECISIONS:

10. Visual Feedback
    - Use different color for multi-select transform widget? (e.g., orange vs blue)
    - Show count badge on selected layers? "3 layers selected"
    - RECOMMENDATION: Different color + count in properties panel header

11. Frame/Pattern Selection
    - Should pattern/frame changes affect multi-selection? 
    - RECOMMENDATION: No, these are CoA-wide settings, not layer-specific

12. Asset Drag-and-Drop
    - What happens when dragging asset with multi-selection active?
    - RECOMMENDATION: Create new layer (current behavior), keep selection


IMPLEMENTATION PHASES
----------------------

PHASE 1: Data Structure (1-2 hours)
- Change selected_layer_index to selected_layer_indices (set)
- Update all references in property_sidebar.py
- Add helper methods: get_selected_indices(), set_selected_indices()
- Test single selection still works

PHASE 2: Selection UI (2-3 hours)
- Add Ctrl/Shift click detection in _select_layer()
- Implement range selection logic
- Update _update_layer_selection() for multiple buttons
- Add "X layers selected" label
- Test selection interactions

PHASE 3: Transform Widget (3-4 hours)
- Calculate screen-space AABB from multiple selected layers
- Implement pivot-based position transforms (translation)
- Implement relative scale transforms (uniform via corners, non-uniform via edges)
- Enable ALL handles for multi-selection (corners, edges, center, rotation)
- Implement group rotation around pivot (positions only, not individual rotations)
- Update transform signal handling for multi-layer application
- Implement screen-space scale application (positions + scale values)
- Test transform operations thoroughly with different rotation values

PHASE 4: Property Panel (1-2 hours)
- Implement "Mixed" value detection
- Update property widgets to show mixed state
- Ensure property changes apply to all selected
- Test property editing

PHASE 5: Layer Operations (1-2 hours)
- Update delete to handle multiple layers
- Update duplicate to handle multiple layers
- Update move up/down for groups
- Update drag reorder for multiple selection
- Test all operations

PHASE 6: Polish & Testing (1-2 hours)
- Add keyboard shortcuts (Ctrl+A, Delete, etc.)
- Visual feedback improvements
- Edge case testing
- Documentation


POTENTIAL ISSUES & MITIGATIONS
-------------------------------

1. ISSUE: Complex transform math for group operations
   MITIGATION: Break down into smaller functions, unit test each transform type

2. ISSUE: Performance with many layers selected
   MITIGATION: Current layer count is typically small (<20), not a concern

3. ISSUE: User confusion about which layers are selected
   MITIGATION: Strong visual feedback, clear count indicator, highlight in list

4. ISSUE: Undo/redo with complex multi-layer operations
   MITIGATION: History system already snapshots full state, should work automatically

5. ISSUE: Clipboard format for multiple layers
   MITIGATION: Extend existing coa_clipboard format with array of colored_emblems

6. ISSUE: Edge cases (empty selection, all layers selected, etc.)
   MITIGATION: Comprehensive testing, guard clauses in all operations

7. ✓ RESOLVED: CK3's rotation-then-scale transform order works WITH screen-space AABB
   INSIGHT: Multi-layer scaling works predictably because:
   - Transform widget represents screen-space AABB
   - CK3's scale operates on screen-space axes
   - Both use the same coordinate system (screen X/Y)
   - Scaling AABB = scaling positions + scaling scale values in same space
   IMPLEMENTATION:
   - Enable all transform handles (corners + edges)
   - Scale AABB horizontally = scale all positions.x + scale all scale_x
   - Scale AABB vertically = scale all positions.y + scale all scale_y
   - Uniform scale = scale both axes proportionally
   - This is intuitive: "stretch the bounding box"
   
8. ✓ CLARIFIED: Transform widget AABB accurately represents screen-space group bounds
   IMPLEMENTATION:
   - Calculate AABB from all selected layer positions (after their transforms)
   - Show screen-aligned rectangle (axis-aligned bounding box)
   - User manipulates the AABB directly
   - Changes apply to positions and scales in screen space
   - This aligns with CK3's transform system


CK3 TRANSFORM SYSTEM AND SCREEN-SPACE AABB APPROACH
----------------------------------------------------

This section documents how CK3's transform order WORKS WELL with a screen-space
AABB (Axis-Aligned Bounding Box) approach for multi-layer selection.

TRANSFORM ORDER:
  CK3 applies transforms in the order: ROTATION → SCALE → POSITION
  
  This is DIFFERENT from typical graphics tools (Photoshop, Illustrator, etc.)
  which usually apply: SCALE → ROTATION → POSITION

KEY INSIGHT:
  Scale values (scale_x, scale_y) are ALWAYS applied to screen X/Y axes,
  NOT to the object's local axes after rotation.
  
  Example:
    Layer A: rotation=0°,  scale={2.0, 1.0} → Wide horizontal rectangle
    Layer B: rotation=90°, scale={2.0, 1.0} → ALSO wide horizontal rectangle!
    
  This seems limiting at first, but it's actually CONSISTENT with a screen-space
  bounding box approach!

WHY SCREEN-SPACE AABB WORKS PERFECTLY:

  The transform widget represents the screen-space AABB of all selected layers.
  Since CK3's scale values are ALSO screen-space, both operate in the same
  coordinate system. This creates consistent, predictable behavior:
  
  1. Calculate AABB from final rendered positions of all layers
  2. User manipulates this screen-aligned bounding box
  3. Scaling the AABB scales:
     a) All layer positions relative to group center (screen-space)
     b) All layer scale_x/scale_y values (also screen-space)
  4. Both operations use the same axes, so results are consistent

EXAMPLE - NON-UNIFORM SCALE:
  
  Setup:
    - Layer A: position={0.3, 0.5}, rotation=0°, scale={1.0, 1.0}
    - Layer B: position={0.7, 0.5}, rotation=90°, scale={1.0, 1.0}
    - Group center: {0.5, 0.5}
    - AABB: left=0.3, right=0.7, width=0.4
  
  User stretches AABB horizontally to 2x width:
    - Scale factor: 2.0 in X, 1.0 in Y
    - Layer A new position: {0.3→0.1, 0.5} (moved left, 2x from center)
    - Layer B new position: {0.7→0.9, 0.5} (moved right, 2x from center)
    - Layer A new scale: {1.0→2.0, 1.0} (horizontally stretched)
    - Layer B new scale: {1.0→2.0, 1.0} (ALSO horizontally stretched)
  
  Visual result:
    - Both layers stretch horizontally in screen space
    - Layer A (rotated 0°): 
      * Emblem content displays at 0° inside a 2.0×1.0 screen-space box
      * AABB: 2.0 wide × 1.0 tall
    - Layer B (rotated 90°):
      * Emblem content displays at 90° inside a 2.0×1.0 screen-space box
      * AABB: 2.0 wide × 1.0 tall (SAME as Layer A!)
    - The group's bounding box stretches horizontally
    - Both layers occupy identical screen-space AABBs despite different rotations
    - Rotation is "like a spinning video" - the VIDEO FRAME (AABB) stays the same
    - Scale is "squashing that video" - directly determines the frame size
    - Per coat_of_arms_format_specifics.txt: "The bounding shape is always
      2:1 horizontal because scale operates on screen axes AFTER rotation"
  
  This is PREDICTABLE because:
    - User is manipulating screen-space AABB
    - CK3 scale operates in screen-space
    - Both align perfectly

IMPACT ON MULTI-LAYER SELECTION:

  1. UNIFORM SCALING (corner handles):
     - Scale AABB proportionally in both dimensions
     - All layers scale uniformly
     - ✓ Works perfectly

  2. NON-UNIFORM SCALING (side handles):
     - Scale AABB in one dimension (horizontal or vertical)
     - All layers scale in that screen-space dimension
     - ✓ Works perfectly - stretches group as expected
     - User mental model: "Stretch the bounding box"

  3. ROTATION (rotation handle):
     - Rotate layer positions around group center
     - Does NOT change individual layer rotation values
     - Layers orbit around pivot while maintaining orientation
     - ✓ Simple and predictable

  4. POSITION (center handle):
     - Move all layers by same delta
     - ✓ Works perfectly

IMPLEMENTATION APPROACH:

  For Multi-Layer Selection:
    - Calculate screen-space AABB from all selected layers' FINAL rendered bounds
      (apply each layer's individual rotation+scale to get actual screen-space extent)
    - Show transform widget aligned to screen axes (not rotated)
    - Enable ALL handles: corners, edges, center, rotation
    - User manipulates the AABB directly
    - Transforms apply to positions and scales in screen-space coordinates
    
  AABB Calculation:
    For each selected layer:
      1. Get layer's position: (pos_x, pos_y)
      2. Get layer's scale: (scale_x, scale_y)
      3. Calculate layer's AABB (position ± scale/2):
         - left = pos_x - scale_x / 2
         - right = pos_x + scale_x / 2
         - top = pos_y - scale_y / 2
         - bottom = pos_y + scale_y / 2
      4. Add to group bounding box calculation
    
    CRITICAL: Individual layer rotation does NOT affect its AABB!
    - Each layer's AABB is simply its scale values as a box at its position
    - Rotation is "like a spinning video" - content rotates inside fixed bounds
    - Scale directly determines the screen-space box size
    - The transform widget never rotates, always axis-aligned
    
    Group Rotation:
    - DURING rotation drag: Keep AABB fixed (don't recalculate in real-time)
    - AFTER rotation drag ends: Recalculate AABB from new layer positions
    - Group rotation translates layer positions around pivot (affects group AABB)
    - This prevents AABB jumping around during rotation handle manipulation
    
    Result: min_x, max_x, min_y, max_y encompassing all layer AABBs
    Group center: ((min_x + max_x) / 2, (min_y + max_y) / 2)
    
  Transform Application Formula:
    For each selected layer:
      1. Calculate offset from group center: offset = layer.pos - group_center
      2. Apply scale: new_offset = offset * scale_factor (element-wise)
      3. Apply rotation: new_offset = rotate(new_offset, rotation_delta)
      4. New position: layer.pos = group_center + new_offset
      5. New scale: layer.scale *= scale_factor (element-wise multiplication)
      6. Rotation unchanged (positions rotate only, not individual rotations)
    
    Example - 2x Uniform Scale:
      Initial:
        - Layer A: pos=(0.4, 0.5), scale=(0.2, 0.2)
        - Layer B: pos=(0.6, 0.5), scale=(0.2, 0.2)
        - Group center: (0.5, 0.5)
      
      After 2x scale:
        - Layer A: pos=(0.3, 0.5), scale=(0.4, 0.4)  # 0.1 offset → 0.2 offset
        - Layer B: pos=(0.7, 0.5), scale=(0.4, 0.4)  # 0.1 offset → 0.2 offset
        - Both positions scaled relative to center
        - Both scale values multiplied by 2x
    
    Negative Scale (Flipping):
      - Flip X: Toggle sign of all scale_x values (-1 ↔ 1)
      - Flip Y: Toggle sign of all scale_y values (-1 ↔ 1)
      - If scale_x > 0, flip makes it negative; if < 0, flip makes it positive
      - Same logic for scale_y
  
  This approach:
    - Aligns with CK3's screen-space transform system
    - Provides intuitive bounding-box manipulation
    - Enables full transform control for multi-selection
    - Produces predictable, consistent results


TESTING STRATEGY
-----------------

UNIT TESTS:
- Selection logic (toggle, range, clear)
- Transform calculations (group bounds, relative transforms)
- Property mixed-value detection
- CK3 transform order math (rotation + scale combinations)

INTEGRATION TESTS:
- Full selection workflows (Ctrl+Click, Shift+Click)
- Transform operations with multiple layers
- Delete/duplicate/move with multiple layers
- Copy/paste with multiple layers
- Undo/redo with multi-selection operations

MANUAL TESTS:
- Select 2-3 layers, move them as group
- Select all layers, change property (color, scale)
- Duplicate 5 layers at once
- Delete multiple layers, verify correct selection after
- Rotate group of 3 layers, check individual rotations
- Scale group uniformly (corner handles)
- Scale group non-uniformly (edge handles) - verify intuitive behavior
- Test with layers at different rotation angles (0°, 45°, 90°, 180°)
- Undo multi-layer operation, verify restore
- Select layers with vastly different rotations and verify uniform scale works


RISK ASSESSMENT
----------------

HIGH RISK:
- None identified

MEDIUM RISK:
- Transform math complexity, especially with CK3's rotation-then-scale order
- Accurate AABB calculation accounting for rotation effects
- User confusion if visual feedback is weak
- Edge cases in selection logic
- User expectations from other tools may not match CK3's transform behavior

LOW RISK:
- Performance issues (layer count is low)
- History system breaking (already robust)
- Breaking existing single-layer workflow

ALTERNATIVES CONSIDERED
-----------------------

1. Layer Grouping Instead of Multi-Select
   - Create explicit groups that can be selected
   - PRO: More structured, familiar from other tools
   - CON: Much more complex, requires group management UI
   - VERDICT: Rejected - Overengineered for this tool's scope

2. Multi-Select for Delete Only
   - Only allow multi-select for deletion, not transforms
   - PRO: Much simpler implementation
   - CON: Limited utility, users expect full multi-select
   - VERDICT: Rejected - Not worth partial implementation

3. Command-Line Multi-Operations
   - Add keyboard commands for "delete all" etc.
   - PRO: Very simple
   - CON: Not discoverable, not standard UI
   - VERDICT: Rejected - Poor UX


RECOMMENDATIONS
----------------

1. PROCEED with implementation using phased approach
2. IMPLEMENT screen-space AABB approach for transform widget
3. IMPLEMENT mixed-value properties for multi-selection
4. IMPLEMENT pivot-based transforms with screen-space scale
5. IMPLEMENT standard desktop multi-select patterns (Ctrl/Shift click)
6. ✓ ENABLE all transform handles (corners, edges, center, rotation)
7. START with Phase 1 (data structures) to validate approach
8. CONSIDER adding visual tests for transform operations
9. DOCUMENT keyboard shortcuts in UI or help menu
10. DOCUMENT screen-space AABB behavior in tooltips/help
11. Group rotation affects positions only, not individual layer rotations


OPEN QUESTIONS - RESOLVED
--------------------------

1. Should there be a limit on max selected layers? (e.g., 50)
   ✓ DECISION: No limit, performance is fine with current layer counts

2. Should selection persist across undo/redo?
   ✓ DECISION: Yes, include selected_layer_indices in state snapshot

3. Should Ctrl+drag duplicate work with multi-selection?
   ✓ DECISION: Yes, duplicate entire group with single offset

4. How to handle selection when loading new CoA file?
   ✓ DECISION: Clear selection when loading new file

5. Group rotation: Should it modify individual layer rotation values?
   ✓ DECISION: No, rotation only affects layer positions around group pivot
   - Simpler implementation and mental model
   - Each layer maintains its individual orientation
   - Positions rotate in circular path around group center
   
6. Should there be a "normalize rotations" feature for multi-selection?
   ✓ DECISION: Defer - Can be added later if users request it

7. Should edge handles (non-uniform scale) be enabled for multi-selection?
   ✓ DECISION: Yes, enable all handles including edge handles
   - Screen-space AABB + screen-space scale = consistent behavior
   - Users can stretch bounding box horizontally/vertically
   - Aligns with CK3's transform system naturally

8. AABB calculation: From center positions or final rendered bounds?
   ✓ DECISION: Calculate from position + scale only (rotation is internal)
   - Each layer's AABB is simply its scale values as a box at its position
   - Individual layer rotation does NOT affect its AABB (rotation is "spinning video")
   - Group AABB encompasses all layer boxes (position ± scale/2)
   - Example: layer at (0.5, 0.5) with scale (0.2, 0.2) has AABB [0.4-0.6, 0.4-0.6]
   - Group rotation DOES affect group AABB by translating layer positions


CONCLUSION
----------

Multi-layer selection is feasible and would significantly improve user workflow
efficiency. The implementation is straightforward with moderate complexity in
the transform calculations. The existing architecture supports the changes well,
and the history system will handle multi-layer operations without modification.

Estimated total time: 8-12 hours of focused development + testing.

Primary challenge: Transform math for screen-space AABB group operations
                  (rotation, scaling) that aligns with CK3's transform system.
Secondary challenge: UI clarity for multiple selection state.
Key insight: Screen-space AABB approach works perfectly with CK3's screen-space
            scale system, enabling full transform control including non-uniform
            scaling for multi-layer selection.

The feature would align with user expectations from other graphics tools while
respecting CK3's unique transform system. All transform operations (move, scale,
rotate) work predictably when applied to the screen-space bounding box.

RECOMMENDED: Proceed with implementation using screen-space AABB approach,
             enabling all transform handles for multi-layer selection.

================================================================================
END OF FEASIBILITY STUDY
================================================================================
