================================================================================
MULTI-LAYER SELECTION IMPLEMENTATION TASKS
CK3 Coat of Arms Editor
================================================================================

BACKGROUND:
See multi_layer_select_feasibility.txt for complete rationale, design decisions,
and technical specifications. This task list implements the screen-space AABB
approach with pivot-based transforms aligned to CK3's transform system.

ESTIMATED TIME: 8-12 hours total


PHASE 1: DATA STRUCTURE CHANGES (1-2 hours)
============================================
References: multi_layer_select_feasibility.txt
- "IMPLEMENTATION REQUIREMENTS" section 1
- "IMPLEMENTATION PHASES" Phase 1

TASK 1.1: Convert selection storage from integer to set
--------------------------------------------------------
Reference: CURRENT SYSTEM ANALYSIS section 1, IMPLEMENTATION REQUIREMENTS section 1
File: src/components/property_sidebar.py
- Change `self.selected_layer_index = None` (line 16) to `self.selected_layer_indices = set()`
- Update type hints and docstrings
- Verify: No syntax errors, file loads

TASK 1.2: Add selection helper methods
---------------------------------------
Reference: IMPLEMENTATION REQUIREMENTS section 1
File: src/components/property_sidebar.py
- Add `get_selected_indices() -> list[int]` - returns sorted list of indices
- Add `set_selected_indices(indices: set[int])` - updates selection state
- Add `is_selected(index: int) -> bool` - checks if index in selection
- Add `clear_selection()` - clears set and updates UI
- Verify: Methods work with empty set and single selection

TASK 1.3: Update all selected_layer_index references
-----------------------------------------------------
Reference: FILES REQUIRING MODIFICATION - all primary files
Files: src/components/property_sidebar.py, src/main.py, src/components/canvas_area.py
- Search for all `selected_layer_index` references
- Replace with appropriate `selected_layer_indices` logic
- Use `get_selected_indices()` when list needed
- Verify: Single selection still works, no crashes


PHASE 2: SELECTION UI (2-3 hours)
==================================
References: multi_layer_select_feasibility.txt
- "IMPLEMENTATION REQUIREMENTS" section 2
- "DESIGN DECISIONS" #5 (LAYER LIST INTERACTION)
- "IMPLEMENTATION PHASES" Phase 2

TASK 2.1: Add modifier key detection to layer click handler
------------------------------------------------------------
Reference: DESIGN DECISIONS #5 Option A (Standard multi-select)
File: src/components/property_sidebar.py
Method: _select_layer(self, index)
- Detect Ctrl key: QApplication.keyboardModifiers() & Qt.ControlModifier
- Detect Shift key: QApplication.keyboardModifiers() & Qt.ShiftModifier
- No modifiers: clear_selection(), add single index
- Ctrl+Click: toggle index in/out of selection
- Shift+Click: select range from last selected to clicked
- Verify: All three modes work correctly

TASK 2.2: Implement range selection logic
------------------------------------------
Reference: DESIGN DECISIONS #5 Option A (Standard multi-select)
File: src/components/property_sidebar.py
- Track `last_selected_index` for range anchor
- On Shift+Click: select all indices between anchor and target (inclusive)
- Handle reversed ranges (clicking above anchor)
- Update `last_selected_index` on any selection change
- Verify: Range selection works in both directions

TASK 2.3: Update layer button visual state for multi-select
------------------------------------------------------------
Reference: IMPLEMENTATION REQUIREMENTS section 2, CURRENT SYSTEM ANALYSIS section 1
File: src/components/property_sidebar.py
Method: _update_layer_selection()
- Iterate through all layer buttons
- Set checked=True for all indices in selected_layer_indices
- Set checked=False for all other indices
- Verify: Multiple buttons can show checked state simultaneously

TASK 2.4: Add selection count indicator
----------------------------------------
Reference: DESIGN DECISIONS #2 Option A, MINOR DECISIONS #10
File: src/components/property_sidebar.py
- Add QLabel above properties tab: "Multiple Layers Selected (X layers)"
- Show when len(selected_layer_indices) > 1
- Update text when selection changes
- Hide when 0 or 1 layers selected
- Verify: Label appears/disappears correctly, count accurate


PHASE 3: TRANSFORM WIDGET (3-4 hours)
======================================
References: multi_layer_select_feasibility.txt
- "CK3 TRANSFORM SYSTEM AND SCREEN-SPACE AABB APPROACH" (entire section)
- "DESIGN DECISIONS" #1 (TRANSFORM WIDGET BEHAVIOR), #3 (TRANSFORM APPLICATION), #4 (ROTATION BEHAVIOR), #9 (NON-UNIFORM SCALING)
- "IMPLEMENTATION PHASES" Phase 3

TASK 3.1: Calculate screen-space AABB for multiple layers
----------------------------------------------------------
Reference: CK3 TRANSFORM SYSTEM section "AABB Calculation", DESIGN DECISIONS #1 Option A, OPEN QUESTIONS #8
File: src/components/canvas_area.py
Method: update_transform_widget_for_layer() - rename to update_transform_widget()
- Accept list of selected indices
- For each index: calculate layer AABB from position ± scale/2
- Calculate group bounds: min_x, max_x, min_y, max_y
- Calculate group center: ((min_x+max_x)/2, (min_y+max_y)/2)
- Return center, width, height for transform widget
- Verify: AABB correct for 2 layers horizontally separated

TASK 3.2: Handle rotation drag without AABB recalculation
----------------------------------------------------------
Reference: CK3 TRANSFORM SYSTEM section "AABB Calculation" - Group Rotation note
File: src/components/transform_widget.py
- Add flag `is_rotating` when rotation handle dragged
- During rotation drag: use cached AABB (don't recalculate)
- On drag end: recalculate AABB from new positions
- Prevents AABB jumping during rotation
- Verify: AABB stays stable during rotation drag

TASK 3.3: Implement group position transform (center handle)
-------------------------------------------------------------
Reference: DESIGN DECISIONS #3 Option C, CK3 TRANSFORM SYSTEM section "Transform Application Formula"
File: src/components/canvas_area.py
- On center handle drag: calculate delta from initial position
- Apply delta to ALL selected layer positions
- Update all layers simultaneously
- Emit signal on drag end for history
- Verify: All selected layers move together maintaining spacing

TASK 3.4: Implement group scale transform (corner handles)
-----------------------------------------------------------
Reference: DESIGN DECISIONS #3 Option C, #9 Option A, CK3 TRANSFORM SYSTEM section "Transform Application Formula" - Example 2x Uniform Scale
File: src/components/canvas_area.py
- Calculate group center before scale
- For each selected layer:
  * offset = layer.pos - group_center
  * new_offset = offset * scale_factor (element-wise)
  * layer.pos = group_center + new_offset
  * layer.scale *= scale_factor (element-wise)
- Verify: Layers scale proportionally, maintain relative positions

TASK 3.5: Implement group scale transform (edge handles)
---------------------------------------------------------
Reference: DESIGN DECISIONS #9 Option A (KEY INSIGHT: SCREEN-SPACE CONSISTENCY), CK3 TRANSFORM SYSTEM section "EXAMPLE - NON-UNIFORM SCALE"
File: src/components/canvas_area.py
- Same as 3.4 but scale_factor has 1.0 in one dimension
- Horizontal edge: scale_factor = (sx, 1.0)
- Vertical edge: scale_factor = (1.0, sy)
- Apply same formula as uniform scale
- Verify: Non-uniform scale works predictably in screen-space

TASK 3.6: Implement group rotation transform (rotation handle)
---------------------------------------------------------------
Reference: DESIGN DECISIONS #4 Option A, OPEN QUESTIONS #5, CK3 TRANSFORM SYSTEM section "Transform Application Formula" - Rotation
File: src/components/canvas_area.py
- Calculate group center as rotation pivot
- For each selected layer:
  * offset = layer.pos - group_center
  * new_offset = rotate_2d(offset, rotation_delta)
  * layer.pos = group_center + new_offset
  * layer.rotation UNCHANGED (positions rotate only)
- Verify: Layers orbit around center, maintain individual orientations

TASK 3.7: Update transform signal handling
-------------------------------------------
Reference: CURRENT SYSTEM ANALYSIS section 2 (Transform Widget), IMPLEMENTATION REQUIREMENTS section 6
File: src/components/canvas_area.py
- Connect transform widget signals to multi-layer handlers
- Ensure drag_finished signal saves history state
- Update property sidebar in real-time during drag
- Verify: Undo works after multi-layer transform


PHASE 4: PROPERTY PANEL (1-2 hours)
====================================
References: multi_layer_select_feasibility.txt
- "DESIGN DECISIONS" #2 (PROPERTY PANEL BEHAVIOR) Option A
- "IMPLEMENTATION REQUIREMENTS" section 4
- "IMPLEMENTATION PHASES" Phase 4

TASK 4.1: Implement mixed value detection
------------------------------------------
Reference: DESIGN DECISIONS #2 Option A (Mixed values)
File: src/components/property_sidebar.py
- Add method: `get_property_value(property_name) -> value | "Mixed"`
- Iterate selected layers, compare property values
- Return actual value if all same, return "Mixed" if different
- Handle numeric properties: position, scale, rotation
- Verify: Returns "Mixed" when values differ, actual value when same

TASK 4.2: Update property display widgets
------------------------------------------
Reference: DESIGN DECISIONS #2 Option A (Mixed values), IMPLEMENTATION REQUIREMENTS section 4
File: src/components/property_sidebar.py
- Modify sliders/spinboxes to show "—" or "Mixed" for mixed values
- When user changes mixed property, apply to ALL selected layers
- Update all property widgets when selection changes
- Verify: Mixed state displays correctly, editing applies to all

TASK 4.3: Update properties tab header
---------------------------------------
Reference: DESIGN DECISIONS #2 Option A ("Multiple Layers Selected (X layers)" label)
File: src/components/property_sidebar.py
- Show "Multiple Layers Selected (X)" when len(selected_layer_indices) > 1
- Show layer name when single selection
- Disable properties tab when no selection
- Verify: Header updates correctly on selection change


PHASE 5: LAYER OPERATIONS (1-2 hours)
======================================
References: multi_layer_select_feasibility.txt
- "DESIGN DECISIONS" #6 (DELETE), #7 (COPY/PASTE), #8 (DUPLICATE)
- "IMPLEMENTATION REQUIREMENTS" section 5
- "IMPLEMENTATION PHASES" Phase 5

TASK 5.1: Update delete operation
----------------------------------
Reference: DESIGN DECISIONS #6 Option B with fallback to A
File: src/components/property_sidebar.py
- Delete all layers in selected_layer_indices (highest index first)
- Select layer at top-most deleted position (if exists)
- Clear selection if no layers remain
- Save history state
- Verify: Multiple delete works, correct layer selected after

TASK 5.2: Update duplicate operation
-------------------------------------
Reference: DESIGN DECISIONS #8 Option A, OPEN QUESTIONS #3
File: src/components/property_sidebar.py
- Duplicate all selected layers with copies
- Apply offset (0.02, 0.02) to all duplicated positions
- Clear old selection, select all newly created layers
- Save history state
- Verify: All selected layers duplicated, new layers selected

TASK 5.3: Update move up/down operations
-----------------------------------------
Reference: IMPLEMENTATION REQUIREMENTS section 5 (Move Up/Down), CURRENT SYSTEM ANALYSIS section 4
File: src/components/property_sidebar.py
- Move all selected layers as a group
- Maintain relative ordering within group
- Update selection indices after move
- Handle edge cases (can't move up if any at top)
- Verify: Group moves together maintaining internal order

TASK 5.4: Update copy/paste operations
---------------------------------------
Reference: DESIGN DECISIONS #7 Option A, POTENTIAL ISSUES #5
File: src/main.py
- Copy: Serialize all selected layers to clipboard (CK3 format)
- Paste: Create all layers from clipboard with small offset
- Maintain CoA format compatibility
- Verify: Multi-layer copy/paste preserves all properties

TASK 5.5: Handle drag reorder with multiple selection
------------------------------------------------------
Reference: IMPLEMENTATION REQUIREMENTS section 5 (Reorder), CURRENT SYSTEM ANALYSIS section 4
File: src/components/property_sidebar.py
- Allow dragging selected group in layer list
- Move all selected layers to new position as group
- Maintain relative ordering
- Update indices after reorder
- Verify: Dragging multiple layers reorders as group


PHASE 6: POLISH & TESTING (1-2 hours)
======================================
References: multi_layer_select_feasibility.txt
- "IMPLEMENTATION REQUIREMENTS" section 7 (Keyboard Shortcuts)
- "TESTING STRATEGY" (entire section)
- "IMPLEMENTATION PHASES" Phase 6

TASK 6.1: Add keyboard shortcuts
---------------------------------
Reference: IMPLEMENTATION REQUIREMENTS section 7 (KEYBOARD SHORTCUTS), RECOMMENDATIONS #9
File: src/main.py
- Ctrl+A: Select all layers
- Ctrl+Shift+A: Deselect all (clear selection)
- Delete key: Delete selected layers (if any)
- Ctrl+C: Copy selected layers
- Ctrl+V: Paste layers
- Ctrl+D or Ctrl+J: Duplicate selected layers
- Verify: All shortcuts work correctly

TASK 6.2: Add visual feedback for multi-select
-----------------------------------------------
Reference: MINOR DECISIONS #10 (Visual Feedback)
File: src/components/transform_widget.py
- Use different color for multi-select widget (e.g., orange vs blue)
- Make widget more prominent when multiple layers selected
- Verify: Visual distinction clear between single/multi-select

TASK 6.3: Handle edge cases
----------------------------
Reference: POTENTIAL ISSUES #6, OPEN QUESTIONS #1, #2, #4
Files: Various
- Empty selection (no crashes)
- All layers selected
- Single layer selected (should work like before)
- Selection during undo/redo (persist in state)
- Clear selection when loading new CoA file
- Verify: No crashes, expected behavior in all cases

TASK 6.4: Test with different scenarios
----------------------------------------
Reference: TESTING STRATEGY section "MANUAL TESTS" (all items)
Manual testing:
- 2 layers horizontally separated, scale uniformly
- 2 layers vertically separated, scale non-uniformly
- 3+ layers rotated, rotate group
- Layers with different rotation values (0°, 45°, 90°, 180°), scale group
- Undo/redo after multi-layer operations
- Copy/paste 5 layers
- Delete all layers
- Verify: All scenarios work predictably

TASK 6.5: Update state persistence
-----------------------------------
Reference: OPEN QUESTIONS #2, #4, CURRENT SYSTEM ANALYSIS section 5 (History System)
File: src/main.py
- Include selected_layer_indices in state snapshot
- Restore selection on undo/redo
- Clear selection on file load/new CoA
- Verify: Selection persists correctly through undo/redo


IMPLEMENTATION NOTES
====================

CRITICAL CONSTRAINTS:
- CK3 transform order: ROTATION → SCALE → POSITION
- Scale operates on screen X/Y axes (not local object axes)
- Individual layer rotation does NOT affect its AABB
- Group rotation DOES affect group AABB (translates positions)
- AABB = position ± scale/2 (simple box, rotation is internal)

TRANSFORM FORMULAS:
- Position: new_pos = old_pos + delta
- Scale: new_pos = group_center + (old_pos - group_center) * scale_factor
         new_scale = old_scale * scale_factor
- Rotation: new_pos = group_center + rotate_2d(old_pos - group_center, angle)
            rotation_value UNCHANGED

KEY DECISIONS (from feasibility study):
- Use screen-space AABB approach (aligns with CK3's screen-space scale)
- Enable ALL transform handles (corners, edges, center, rotation)
- Group rotation affects positions only (not individual rotations)
- Show "Mixed" for different property values
- Apply changes to all selected layers simultaneously

TESTING FOCUS:
- AABB calculation with various layer configurations
- Transform math accuracy (especially with different rotations)
- Selection UI interactions (Ctrl/Shift click)
- Undo/redo with multi-layer operations
- Edge cases (empty selection, all selected, single selected)


================================================================================
END OF TASK LIST
================================================================================
