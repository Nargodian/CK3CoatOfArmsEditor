================================================================================
CK3 COAT OF ARMS EDITOR - MULTI-INSTANCE INTEGRATION PLAN
================================================================================
Document Date: January 29, 2026
Purpose: Detailed analysis of how to integrate Phase 2 multi-instance system 
         into the transform widget and rendering pipeline
================================================================================

TABLE OF CONTENTS
1. CURRENT SYSTEM OVERVIEW
2. DATA MODEL EVOLUTION (Pre-Phase 2 → Phase 2)
3. EVENT FLOW AND DATA INTERACTIONS
4. TRANSFORM WIDGET ARCHITECTURE
5. RENDERING PIPELINE
6. PROBLEM ANALYSIS
7. INTEGRATION STRATEGY
8. RISK ASSESSMENT

================================================================================
1. CURRENT SYSTEM OVERVIEW
================================================================================

The editor has THREE main data interaction points:
1. canvas_widget.py  - OpenGL rendering (reads layer data)
2. canvas_area.py    - Transform widget coordinator (reads/writes layer data)
3. property_sidebar.py - Property editor (reads/writes layer data)

Supporting modules:
- transform_widget.py - Interactive handles for position/scale/rotation
- layer_operations.py - Layer manipulation functions
- file_operations.py  - Import/export

Key Coordinate Systems:
- Layer Position: [0-1] normalized (0.5, 0.5 = center)
- OpenGL NDC: [-1, +1] normalized device coordinates
- Qt Pixels: Widget pixel coordinates
- Conversion functions in canvas_widget.py:
  * layer_pos_to_opengl_coords()
  * layer_pos_to_qt_pixels()
  * qt_pixels_to_layer_pos()

================================================================================
2. DATA MODEL EVOLUTION (Pre-Phase 2 → Phase 2)
================================================================================

OLD FORMAT (Pre-Phase 2):
--------------------------
layer = {
    'filename': 'ce_eagle.dds',
    'colors': 3,
    'pos_x': 0.5,        # Direct property at root level
    'pos_y': 0.5,
    'scale_x': 0.3,
    'scale_y': 0.3,
    'rotation': 0,
    'depth': 0.0,
    'flip_x': False,
    'flip_y': False,
    'color1': [r, g, b],
    'color2': [r, g, b],
    'color3': [r, g, b],
    'mask': [0, 0, 0]
}

NEW FORMAT (Phase 2 Multi-Instance):
-------------------------------------
layer = {
    'filename': 'ce_eagle.dds',
    'colors': 3,
    'instances': [           # Array of instances (atomic group)
        {
            'pos_x': 0.5,    # Instance-specific properties
            'pos_y': 0.5,
            'scale_x': 0.3,
            'scale_y': 0.3,
            'rotation': 0,
            'depth': 0.0
        },
        {
            'pos_x': 0.7,    # Second instance (same emblem, different transform)
            'pos_y': 0.3,
            'scale_x': 0.2,
            'scale_y': 0.2,
            'rotation': 45,
            'depth': 0.0
        }
    ],
    'selected_instance': 0,  # Which instance is being edited
    'flip_x': False,         # Shared properties (apply to ALL instances)
    'flip_y': False,
    'color1': [r, g, b],
    'color2': [r, g, b],
    'color3': [r, g, b],
    'mask': [0, 0, 0]
}

CRITICAL INSIGHT:
- OLD: layer['pos_x'] directly accessible
- NEW: layer['instances'][layer['selected_instance']]['pos_x']
- Migration function: _migrate_layer_to_instances() in layer_operations.py

================================================================================
3. EVENT FLOW AND DATA INTERACTIONS
================================================================================

3.1 APPLICATION STARTUP
------------------------
main.py
  └─> Creates canvas_area (CanvasArea)
       ├─> Creates canvas_widget (CoatOfArmsCanvas)
       └─> Creates transform_widget (TransformWidget)
  └─> Creates property_sidebar (PropertySidebar)
  └─> Connects references:
       property_sidebar.canvas_widget = canvas_widget
       canvas_area.property_sidebar = property_sidebar

3.2 FILE LOAD FLOW
------------------
User: File → Open
  └─> file_operations.load_coa_from_file()
       └─> coa_parser.parse_coa_file()
            └─> Parses raw CK3 format
  └─> layer_operations._emblem_to_layer_data()
       └─> Converts to internal format (Phase 2: creates instances array)
  └─> property_sidebar.set_layers(layers)
       └─> Stores layers list
       └─> Updates layer list UI
  └─> canvas_widget.set_layers(layers)
       └─> Stores layers for rendering
       └─> Triggers repaint

DATA STATE: Layers now in Phase 2 format with instances array

3.3 LAYER SELECTION FLOW
-------------------------
User: Clicks layer in sidebar
  └─> property_sidebar._on_layer_clicked(index)
       └─> Updates selected_layer_indices set
       └─> Calls _load_layer_properties()
            └─> Reads from instances[selected_instance]
       └─> Calls canvas_area.update_transform_widget_for_layer()

canvas_area.update_transform_widget_for_layer():
  ├─> SINGLE SELECTION:
  │    └─> Reads layer['pos_x'], layer['scale_x'], etc.  ← PROBLEM!
  │         (Should read from instances[selected_instance])
  │    └─> Calls transform_widget.set_transform()
  │    └─> Shows transform widget at layer position
  │
  └─> MULTI-SELECTION:
       └─> Calculates AABB from all selected layers
       └─> Reads layer.get('pos_x'), layer.get('scale_x')  ← PROBLEM!
       └─> Calls transform_widget.set_transform()
       └─> Shows group transform widget

DATA READ: canvas_area.py lines 206, 233, 316 read OLD format

3.4 TRANSFORM WIDGET INTERACTION
---------------------------------
User: Drags transform handle
  └─> transform_widget.mouseMoveEvent()
       └─> Calculates new transform values
       └─> Emits transformChanged(pos_x, pos_y, scale_x, scale_y, rotation)

canvas_area._on_transform_changed():
  ├─> SINGLE SELECTION:
  │    └─> layer['pos_x'] = new_pos_x  ← PROBLEM!
  │         (Should write to instances[selected_instance]['pos_x'])
  │    └─> Calls canvas_widget.set_layers()
  │
  └─> MULTI-SELECTION:
       └─> Calculates group transform
       └─> For each layer in selection:
            └─> layer['pos_x'] = calculated_pos  ← PROBLEM!

DATA WRITE: canvas_area.py line 288, 435 write OLD format

3.5 RENDERING FLOW
------------------
canvas_widget.paintGL():
  └─> _render_coa_to_framebuffer()
       └─> For each layer in self.layers:
            └─> Reads layer.get('pos_x'), layer.get('scale_x')  ← PROBLEM!
            └─> Calculates vertices
            └─> Renders to OpenGL

DATA READ: canvas_widget.py line 417 reads OLD format

3.6 PROPERTY EDITING FLOW
--------------------------
User: Changes position slider in sidebar
  └─> property_sidebar._on_position_x_changed(value)
       └─> Calls _update_layer_property('pos_x', value)
            └─> Writes to instances[selected_instance]['pos_x']  ✓ CORRECT
       └─> Calls canvas_widget.set_layers()
       └─> Calls canvas_area.update_transform_widget_for_layer()
            └─> Re-reads layer data to update widget position

DATA WRITE: property_sidebar.py correctly uses instances format

================================================================================
4. TRANSFORM WIDGET ARCHITECTURE
================================================================================

4.1 TRANSFORM WIDGET RESPONSIBILITIES
--------------------------------------
File: editor/src/components/transform_widget.py

The TransformWidget is a transparent overlay that:
- Renders interactive handles (corners, edges, center, rotation)
- Handles mouse events (press, move, release)
- Calculates transform deltas
- Emits signals when transforms change
- Does NOT directly access layer data

Key Methods:
- set_transform(pos_x, pos_y, scale_x, scale_y, rotation)
  * Updates internal state
  * Triggers repaint
- mousePressEvent() → Detects which handle clicked
- mouseMoveEvent() → Calculates new transform, emits transformChanged signal
- mouseReleaseEvent() → Emits transformEnded signal

Key Signals:
- transformChanged(pos_x, pos_y, scale_x, scale_y, rotation)
  * Emitted during drag
  * Connected to canvas_area._on_transform_changed()
- transformEnded()
  * Emitted when drag completes
  * Connected to canvas_area._on_transform_ended()

4.2 CANVAS AREA RESPONSIBILITIES
---------------------------------
File: editor/src/components/canvas_area.py

The CanvasArea coordinates the transform widget:
- Positions transform widget based on layer data
- Receives transform changes from widget
- Applies changes to actual layer data
- Updates canvas rendering

Key Methods:
- update_transform_widget_for_layer(layer_index)
  * Reads layer data (pos, scale, rotation)
  * Calls transform_widget.set_transform()
  * For multi-selection: calculates AABB
  
- _on_transform_changed(pos_x, pos_y, scale_x, scale_y, rotation)
  * Writes new values to layer data
  * Single selection: direct write
  * Multi-selection: calculates proportional transforms for all layers
  
- _on_transform_ended()
  * Clears drag cache
  * Saves undo state
  * Reloads properties sidebar

4.3 SINGLE VS MULTI-SELECTION LOGIC
------------------------------------

SINGLE SELECTION (1 layer selected):
- Transform widget shows at exact layer position
- Direct 1:1 mapping: widget transform = layer transform
- Simple read/write of layer properties

MULTI-SELECTION (2+ layers selected):
- Transform widget shows at group AABB (axis-aligned bounding box)
- AABB calculated from min/max of all layer positions ± scales/2
- Transforms are proportional:
  * Widget moves → All layers move by same delta
  * Widget scales → All layers scale proportionally from group center
  * Widget rotates → All layers orbit around group center
- Cache mechanism prevents cumulative errors:
  * _drag_start_layers saves original positions
  * All calculations based on original state
  * Reset when selection changes

ROTATION BEHAVIOR (Task 3.6):
- Multi-selection rotation = "Ferris wheel" behavior
- Layers orbit around group center
- Individual layer rotations preserved (not modified)
- Cached AABB prevents inflation during rotation

================================================================================
5. RENDERING PIPELINE
================================================================================

5.1 OPENGL RENDERING ARCHITECTURE
----------------------------------
File: editor/src/components/canvas_widget.py

The canvas uses a Render-To-Texture (RTT) pipeline:

Step 1: Render CoA to Framebuffer (512x512 canonical space)
  _render_coa_to_framebuffer()
    ├─> Render base pattern (fills framebuffer)
    └─> For each layer:
         ├─> Read transform: pos_x, pos_y, scale_x, scale_y, rotation
         ├─> Convert to OpenGL coordinates
         ├─> Apply rotation matrix
         ├─> Calculate vertex positions
         └─> Render to framebuffer

Step 2: Composite to Viewport
  _composite_to_viewport()
    └─> Render framebuffer texture to screen with frame mask

Step 3: Render Frame
  _render_frame()
    └─> Render frame graphic on top

5.2 LAYER RENDERING LOGIC
--------------------------
Lines 375-480 in canvas_widget.py:

for layer in self.layers:
    if not layer.get('visible', True):
        continue
    
    # Read transform properties
    pos_x = layer.get('pos_x', 0.5)         ← READS OLD FORMAT
    pos_y = layer.get('pos_y', 0.5)
    scale_x = layer.get('scale_x', 0.5)
    scale_y = layer.get('scale_y', 0.5)
    rotation = layer.get('rotation', 0)
    flip_x = layer.get('flip_x', False)
    flip_y = layer.get('flip_y', False)
    
    # Convert to OpenGL coords
    center_x, center_y = layer_pos_to_opengl_coords(pos_x, pos_y)
    
    # Apply rotation and calculate vertices
    # ... vertex calculations ...
    
    # Render quad
    gl.glDrawElements(...)

CURRENT STATE: Renders only FIRST instance (or none if old format gone)

5.3 MULTI-INSTANCE RENDERING REQUIREMENTS
------------------------------------------
To support multi-instance, rendering needs to:

1. Iterate through ALL instances in layer['instances']
2. For EACH instance:
   - Read instance['pos_x'], instance['pos_y'], etc.
   - Apply shared properties (flip_x, flip_y, colors, mask)
   - Render emblem at instance position

Pseudocode:
for layer in self.layers:
    instances = layer.get('instances', [])
    
    # Shared properties (read once)
    flip_x = layer.get('flip_x', False)
    flip_y = layer.get('flip_y', False)
    colors = layer.get('color1'), layer.get('color2'), layer.get('color3')
    
    # Render each instance
    for instance in instances:
        pos_x = instance.get('pos_x', 0.5)
        pos_y = instance.get('pos_y', 0.5)
        scale_x = instance.get('scale_x', 0.5)
        scale_y = instance.get('scale_y', 0.5)
        rotation = instance.get('rotation', 0)
        
        # ... render logic ...

================================================================================
6. PROBLEM ANALYSIS
================================================================================

6.1 ROOT CAUSE IDENTIFICATION
------------------------------
The Phase 2 data model changed the storage location of transform properties:
- OLD: layer['pos_x']
- NEW: layer['instances'][selected_instance]['pos_x']

However, THREE components still access the OLD format:

COMPONENT 1: canvas_area.py (Transform Widget Coordinator)
  Problem Locations:
  - Line 206: pos_x = layer.get('pos_x', 0.5)  [SINGLE SELECTION READ]
  - Line 233: pos_x = layer.get('pos_x', 0.5)  [MULTI AABB CALCULATION]
  - Line 316: 'pos_x': layer.get('pos_x', 0.5) [MULTI CACHE INITIALIZATION]
  - Line 288: layer['pos_x'] = new_pos_x       [SINGLE SELECTION WRITE]
  - Line 435: layer['pos_x'] = new_pos_x       [MULTI SELECTION WRITE]
  
  Impact: Transform widget shows at wrong position (or doesn't show)
  Impact: Dragging transform handles doesn't update layer data

COMPONENT 2: canvas_widget.py (OpenGL Renderer)
  Problem Locations:
  - Line 417: pos_x = layer.get('pos_x', 0.5)  [RENDER LOOP]
  
  Impact: Layers don't render (or render at default position)

COMPONENT 3: property_sidebar.py (Property Editor)
  Status: ✓ ALREADY FIXED
  - get_property_value() correctly reads from instances
  - _update_layer_property() correctly writes to instances

6.2 WHY PREVIOUS FIXES FAILED
------------------------------
Multiple attempts to patch canvas_area.py failed because:

1. Indentation Errors
   - Python is whitespace-sensitive
   - Copy-paste errors introduced incorrect indentation
   - Code blocks ended up outside their intended scope

2. Incomplete Context
   - Attempted to fix one location without understanding data flow
   - Didn't account for cache initialization vs. cache usage
   - Didn't consider single vs. multi-selection code paths

3. Circular Patching
   - Fixed one issue, broke another
   - Each fix created new syntax errors
   - Lost track of overall code structure

4. Testing Blind Spots
   - Fixed canvas_area.py but canvas_widget.py still broken
   - Application started but layers didn't render
   - Transform appeared to work but didn't update data

================================================================================
7. INTEGRATION STRATEGY
================================================================================

7.1 PHASE 1: RENDERING (canvas_widget.py)
------------------------------------------
Priority: HIGH (nothing renders without this)
Risk: LOW (isolated change, clear requirements)

Current Code (Line ~375-480):
for layer in self.layers:
    pos_x = layer.get('pos_x', 0.5)
    pos_y = layer.get('pos_y', 0.5)
    # ... single render ...

Target Code:
for layer in self.layers:
    instances = layer.get('instances', [])
    if not instances:
        continue  # Skip layers with no instances
    
    # Read shared properties once
    flip_x = layer.get('flip_x', False)
    flip_y = layer.get('flip_y', False)
    colors = (layer.get('color1'), layer.get('color2'), layer.get('color3'))
    mask = layer.get('mask')
    
    # Render each instance
    for instance in instances:
        pos_x = instance.get('pos_x', 0.5)
        pos_y = instance.get('pos_y', 0.5)
        scale_x = instance.get('scale_x', 0.5)
        scale_y = instance.get('scale_y', 0.5)
        rotation = instance.get('rotation', 0)
        
        # ... existing vertex calculation code ...
        # ... existing render call ...

Changes Required:
1. Add outer loop: for instance in instances
2. Move instance properties inside loop
3. Move shared properties outside loop
4. Indent existing render code one level

Testing:
- Open file with single-instance layers → Should render
- Open file with multi-instance layers → Should render all instances
- Edit instance position → Should update immediately

7.2 PHASE 2: TRANSFORM READING (canvas_area.py)
------------------------------------------------
Priority: HIGH (transform widget won't show without this)
Risk: MEDIUM (multiple code paths, careful indexing needed)

Three read locations to fix:

LOCATION 1: Single Selection Transform (Line 206)
Current:
    pos_x = layer.get('pos_x', 0.5)
    pos_y = layer.get('pos_y', 0.5)
    scale_x = layer.get('scale_x', 0.5)
    scale_y = layer.get('scale_y', 0.5)
    rotation = layer.get('rotation', 0)

Target:
    instances = layer.get('instances', [])
    selected_inst = layer.get('selected_instance', 0)
    if not instances or selected_inst >= len(instances):
        # Fallback to defaults if no instances
        pos_x, pos_y = 0.5, 0.5
        scale_x, scale_y = 0.5, 0.5
        rotation = 0
    else:
        inst = instances[selected_inst]
        pos_x = inst.get('pos_x', 0.5)
        pos_y = inst.get('pos_y', 0.5)
        scale_x = inst.get('scale_x', 0.5)
        scale_y = inst.get('scale_y', 0.5)
        rotation = inst.get('rotation', 0)

LOCATION 2: Multi-Selection AABB Calculation (Line 233)
Current:
    pos_x = layer.get('pos_x', 0.5)
    pos_y = layer.get('pos_y', 0.5)
    scale_x = layer.get('scale_x', 0.5)
    scale_y = layer.get('scale_y', 0.5)

Target:
    instances = layer.get('instances', [])
    selected_inst = layer.get('selected_instance', 0)
    if not instances or selected_inst >= len(instances):
        continue  # Skip layers with no instances
    
    inst = instances[selected_inst]
    pos_x = inst.get('pos_x', 0.5)
    pos_y = inst.get('pos_y', 0.5)
    scale_x = inst.get('scale_x', 0.5)
    scale_y = inst.get('scale_y', 0.5)

LOCATION 3: Multi-Selection Cache Initialization (Line 316)
Current:
    self._drag_start_layers.append({
        'index': idx,
        'pos_x': layer.get('pos_x', 0.5),
        'pos_y': layer.get('pos_y', 0.5),
        'scale_x': layer.get('scale_x', 0.5),
        'scale_y': layer.get('scale_y', 0.5)
    })

Target:
    instances = layer.get('instances', [])
    selected_inst = layer.get('selected_instance', 0)
    if not instances or selected_inst >= len(instances):
        continue
    
    inst = instances[selected_inst]
    self._drag_start_layers.append({
        'index': idx,
        'pos_x': inst.get('pos_x', 0.5),
        'pos_y': inst.get('pos_y', 0.5),
        'scale_x': inst.get('scale_x', 0.5),
        'scale_y': inst.get('scale_y', 0.5)
    })

Testing:
- Select single layer → Widget shows at correct position
- Select multiple layers → Widget shows at correct group AABB
- Change selection → Widget updates to new position

7.3 PHASE 3: TRANSFORM WRITING (canvas_area.py)
------------------------------------------------
Priority: HIGH (edits won't persist without this)
Risk: HIGH (multi-selection has complex logic, easy to break)

Two write locations to fix:

LOCATION 1: Single Selection Write (Line 288)
Current:
    layer['pos_x'] = max(0.0, min(1.0, pos_x))
    layer['pos_y'] = max(0.0, min(1.0, pos_y))
    layer['scale_x'] = scale_x
    layer['scale_y'] = scale_y
    layer['rotation'] = rotation

Target:
    instances = layer.get('instances', [])
    selected_inst = layer.get('selected_instance', 0)
    if instances and 0 <= selected_inst < len(instances):
        instances[selected_inst]['pos_x'] = max(0.0, min(1.0, pos_x))
        instances[selected_inst]['pos_y'] = max(0.0, min(1.0, pos_y))
        instances[selected_inst]['scale_x'] = scale_x
        instances[selected_inst]['scale_y'] = scale_y
        instances[selected_inst]['rotation'] = rotation

LOCATION 2: Multi-Selection Write (Line 435) *** MOST COMPLEX ***
Current:
    layer['pos_x'] = new_pos_x
    layer['pos_y'] = new_pos_y
    layer['scale_x'] = new_scale_x
    layer['scale_y'] = new_scale_y

Target:
    instances = layer.get('instances', [])
    selected_inst = layer.get('selected_instance', 0)
    if instances and 0 <= selected_inst < len(instances):
        instances[selected_inst]['pos_x'] = new_pos_x
        instances[selected_inst]['pos_y'] = new_pos_y
        instances[selected_inst]['scale_x'] = new_scale_x
        instances[selected_inst]['scale_y'] = new_scale_y
    # Note: rotation NOT modified (Task 3.6)

CRITICAL: This is inside the for loop over _drag_start_layers
CRITICAL: Must preserve existing clamping logic
CRITICAL: Must NOT modify individual layer rotations

Testing:
- Drag single layer → Position updates, persists after save/load
- Drag multiple layers → All layers move proportionally
- Scale single layer → Scale updates
- Scale multiple layers → All scale proportionally
- Rotate multiple layers → Layers orbit (individual rotations preserved)

7.4 PHASE 4: VALIDATION & EDGE CASES
-------------------------------------
Priority: MEDIUM (defensive programming)
Risk: LOW (improves robustness)

Edge Cases to Handle:
1. Empty instances array
   - Should not crash
   - Maybe auto-migrate or show warning

2. Invalid selected_instance index
   - selected_instance >= len(instances)
   - Should clamp to 0 or len-1

3. Mixed format layers (some old, some new)
   - Migration function should handle
   - property_sidebar already calls _migrate_layer_to_instances()

4. Undo/Redo with instances
   - History system stores full layer state
   - Should work automatically (deep copy)

5. Copy/Paste with instances
   - clipboard_actions.py uses serialize_layer_to_text()
   - Already supports instances (Phase 2A)

================================================================================
8. RISK ASSESSMENT
================================================================================

8.1 TECHNICAL RISKS
--------------------

HIGH RISK AREAS:
1. Multi-selection transform write (canvas_area.py line 435)
   - Inside nested loop with complex math
   - Easy to introduce off-by-one errors
   - Affects multiple layers simultaneously

2. Rendering loop indentation (canvas_widget.py line 375)
   - Adding nested loop requires careful indentation
   - One tab off = syntax error
   - Large function (100+ lines) makes context tricky

MEDIUM RISK AREAS:
3. AABB calculation with instances
   - Needs to read selected_instance correctly
   - Math must account for instance positions
   - Rotation cache logic is delicate

LOW RISK AREAS:
4. Single selection read/write
   - Simple 1:1 mapping
   - Clear before/after
   - Easy to test

8.2 TESTING STRATEGY
---------------------

UNIT TESTING (Not currently in project):
- Would require pytest
- Could test coordinate conversion functions
- Could test _migrate_layer_to_instances()

MANUAL TESTING (Current approach):
1. Open sample file → Verify renders
2. Select layer → Verify widget shows
3. Drag layer → Verify moves
4. Multi-select → Verify group transform
5. Save file → Verify persists
6. Reload file → Verify correct

REGRESSION TESTING:
- Test all existing functionality still works
- Check undo/redo
- Check copy/paste
- Check alignment tools
- Check split/merge (Phase 2C)

8.3 ROLLBACK PLAN
------------------
All files are in git, can revert:
  git checkout editor/src/components/canvas_area.py
  git checkout editor/src/components/canvas_widget.py

Migration functions are backward-compatible:
- Old format layers auto-migrate on load
- _migrate_layer_to_instances() is idempotent

8.4 DEVELOPMENT HISTORY INSIGHTS
---------------------------------
From git log analysis:

Recent transform-related commits:
- 305730d: Fix align layers bug
- 8754a37: Move minimal transform button
- 1b1510c: Add Alt+drag anchored scaling
- f67c262: Add minimal transform toggle
- 8b4a07d: Simplify coordinate system [KEY COMMIT]
- 5481c3a: Fix transform widget parallax

Key commit 8b4a07d (Simplify coordinate system):
- Unified coordinate conversion functions
- Fixed transform widget dragging issues
- Shows pattern of coordinate system bugs
- Transform widget is SENSITIVE to coordinate mappings

Lesson: Transform system has history of coordinate bugs
Lesson: Coordinate conversion functions are critical
Lesson: Test with multiple zoom levels and window sizes

================================================================================
9. IMPLEMENTATION CHECKLIST
================================================================================

PHASE 1: RENDERING ✓ (Should be done first)
[ ] Read canvas_widget.py lines 375-480 (current render loop)
[ ] Add nested loop: for instance in instances
[ ] Move instance properties inside loop
[ ] Move shared properties (flip, colors, mask) outside loop
[ ] Test rendering with sample files
[ ] Verify multi-instance layers show all instances

PHASE 2: TRANSFORM READING ✓
[ ] Fix canvas_area.py line 206 (single selection read)
[ ] Fix canvas_area.py line 233 (multi AABB calculation)
[ ] Fix canvas_area.py line 316 (multi cache initialization)
[ ] Test transform widget shows at correct position
[ ] Test multi-selection AABB is correct

PHASE 3: TRANSFORM WRITING ✓
[ ] Fix canvas_area.py line 288 (single selection write)
[ ] Fix canvas_area.py line 435 (multi selection write)
[ ] CAREFULLY preserve indentation and loop structure
[ ] Test dragging single layer updates data
[ ] Test dragging multiple layers works proportionally
[ ] Test rotation preserves individual layer rotations

PHASE 4: VALIDATION ✓
[ ] Test with empty instances array
[ ] Test with invalid selected_instance
[ ] Test undo/redo
[ ] Test copy/paste
[ ] Test save/load round-trip
[ ] Test split/merge operations

================================================================================
10. FINAL NOTES
================================================================================

KEY SUCCESS FACTORS:
1. Fix rendering FIRST (provides immediate visual feedback)
2. Fix read locations SECOND (transform widget will show)
3. Fix write locations THIRD (edits will persist)
4. Test incrementally after each phase
5. Don't batch multiple fixes - test each one

COMMON PITFALLS TO AVOID:
1. Indentation errors (Python is whitespace-sensitive!)
2. Off-by-one errors with selected_instance index
3. Forgetting to check for empty instances array
4. Modifying rotation in multi-selection (should preserve)
5. Breaking AABB cache logic (delicate for rotation)

DEBUGGING TIPS:
1. Add print() statements to see what data looks like
2. Check layer structure with json.dumps(layer, indent=2)
3. Verify instances array exists and is non-empty
4. Verify selected_instance is valid index
5. Run application and watch console for errors

SUCCESS CRITERIA:
✓ Application starts without errors
✓ Layers render correctly (all instances visible)
✓ Transform widget shows at correct position
✓ Dragging transform updates layer data
✓ Multi-selection group transform works
✓ Rotation preserves individual layer rotations
✓ Save/load round-trip preserves all instances
✓ Undo/redo works correctly
✓ Copy/paste preserves instances

================================================================================
END OF DOCUMENT
================================================================================
