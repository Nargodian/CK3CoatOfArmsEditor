================================================================================
INTEGRATION CONFIDENCE DOCUMENT - Multi-Instance Transform Integration
================================================================================
Created: After extensive code archaeology and working pattern analysis
Purpose: Build confidence for Phase 2 implementation by documenting patterns,
         identifying risks, and providing actionable fix strategies

================================================================================
PART 1: WHAT ACTUALLY WORKS (The Success Pattern)
================================================================================

1.1 PROPERTY_SIDEBAR.PY - THE GOLD STANDARD
--------------------------------------------
Location: editor/src/components/property_sidebar.py
Status: ✓ WORKING CORRECTLY - Full instance support

Key Success Factors:
- Lines 1167-1204: _update_layer_property() method is CENTRALIZED
- Lines 106-154: get_property_value() reads from correct source
- Defensive programming: Checks exist, validates bounds, auto-migrates
- Single responsibility: One method handles all property updates

The Working Pattern:
```python
# 1. Define which properties live in instances
instance_properties = ['pos_x', 'pos_y', 'scale_x', 'scale_y', 'rotation', 'depth']

# 2. In _update_layer_property():
if prop_name in instance_properties:
    # Auto-migrate old format
    _migrate_layer_to_instances(layer)
    
    # Safely access instances
    instances = layer.get('instances', [])
    selected_inst = layer.get('selected_instance', 0)
    
    # Validate bounds
    if 0 <= selected_inst < len(instances):
        instances[selected_inst][prop_name] = value
    
# 3. Update flow: data → canvas → widget
layer_data[prop_name] = value
canvas_widget.set_layers(layers)  # Trigger render update
update_transform_widget_for_layer()  # Sync widget
```

Why This Works:
- Auto-migration prevents old format from causing crashes
- Bounds checking prevents index errors
- Centralization ensures consistency
- Clear separation: data update → visual update → widget update

Connections to Transform System:
- Line 1206: _update_layer_property_and_widget() calls update_transform_widget_for_layer()
- Lines 458, 462, 472: All sliders funnel through this method
- Transform widget reads updated layer data via update_transform_widget_for_layer()

1.2 LAYER_OPERATIONS.PY - THE FOUNDATION
-----------------------------------------
Location: editor/src/services/layer_operations.py
Status: ✓ WORKING CORRECTLY - Provides migration and creation functions

Key Functions:
- Lines 54-99: create_default_layer() - Creates layers with instances format
- Lines 102-130: _migrate_layer_to_instances() - Converts old → new format
- Lines 133-180: duplicate_layer() - Handles instance lists correctly

Migration Function (Lines 102-130):
```python
def _migrate_layer_to_instances(layer_data):
    # Check if already migrated
    if 'instances' in layer_data and isinstance(layer_data['instances'], list):
        # Clean up old fields
        for key in ['pos_x', 'pos_y', 'scale_x', 'scale_y', 'rotation', 'depth']:
            layer_data.pop(key, None)
        return
    
    # Build instance from old format
    instance = {
        'pos_x': layer_data.pop('pos_x', DEFAULT_POSITION_X),
        'pos_y': layer_data.pop('pos_y', DEFAULT_POSITION_Y),
        'scale_x': layer_data.pop('scale_x', DEFAULT_SCALE_X),
        'scale_y': layer_data.pop('scale_y', DEFAULT_SCALE_Y),
        'rotation': layer_data.pop('rotation', DEFAULT_ROTATION),
        'depth': layer_data.pop('depth', 0.0)
    }
    
    layer_data['instances'] = [instance]
    layer_data['selected_instance'] = 0
```

Why This Works:
- Idempotent: Can be called multiple times safely
- Defensive: Checks format before migrating
- Complete: Removes old fields to prevent confusion
- Available: Centralized utility used by multiple modules

Usage Pattern:
- file_operations.py: Calls before export (lines 88, 177)
- property_sidebar.py: Calls before accessing instance properties
- layer_operations.py: Calls in duplicate_layer()

1.3 FILE_OPERATIONS.PY - IMPORT/EXPORT BRIDGE
----------------------------------------------
Location: editor/src/services/file_operations.py
Status: ✓ WORKING CORRECTLY - Handles instances in save/load

Key Features:
- Lines 88-115: Auto-migrates before export (build_coa_for_save)
- Lines 92-107: Iterates instances correctly for export
- Lines 177-207: Auto-migrates before clipboard (build_coa_for_clipboard)

Export Pattern (Lines 92-107):
```python
# Migrate old format if needed
if 'pos_x' in layer and 'instances' not in layer:
    from services.layer_operations import _migrate_layer_to_instances
    _migrate_layer_to_instances(layer)

# Build instances list
instances = []
for inst in layer.get('instances', []):
    instance = {
        "position": [inst.get('pos_x', 0.5), inst.get('pos_y', 0.5)],
        "scale": [inst.get('scale_x', 1.0), inst.get('scale_y', 1.0)],
        "rotation": int(inst.get('rotation', 0))
    }
    instances.append(instance)
```

Why This Works:
- Migrates before accessing to ensure safety
- Uses defensive .get() with defaults
- Maintains data integrity during serialization
- No assumptions about format

================================================================================
PART 2: WHAT'S BROKEN (The Problems)
================================================================================

2.1 CANVAS_AREA.PY - THE BROKEN TRANSFORM CONTROLLER
-----------------------------------------------------
Location: editor/src/components/canvas_area.py
Status: ❌ BROKEN - Uses old format, no migration

Problem Locations:
1. Lines 206-215: _update_transform_widget_single_selection()
   - Reads layer['pos_x'], layer['pos_y'] directly
   - No instance awareness
   - No migration
   
2. Lines 233-246: _update_transform_widget_multi_selection()
   - Reads layer['pos_x'], layer['pos_y'] for AABB calculation
   - Iterates all selected layers using old format
   - AABB calculation fails with None values
   
3. Lines 316-325: _init_drag_with_multi_selection()
   - Caches layer['pos_x'], layer['pos_y'] for drag start
   - Creates _drag_start_layers cache with old format
   
4. Lines 288-296: _apply_drag_transform_multi_selection()
   - Writes layer['pos_x'], layer['pos_y'] directly
   - No instance update
   
5. Lines 435-444: _on_transform_widget_changed()
   - Writes layer['pos_x'], layer['pos_y'], layer['rotation'] directly
   - Transform widget changes don't reach instances

Root Cause:
- canvas_area.py predates Phase 2 multi-instance architecture
- Never updated when data model changed
- No centralized property access pattern
- Inline property access scattered throughout

Why Transform Widget Doesn't Work:
1. Widget positioned based on layer['pos_x'] (which is None/missing)
2. Widget changes write to layer['pos_x'] (instances not updated)
3. Render uses instances, widget uses old format → mismatch
4. Canvas shows correct position, widget appears at wrong location
5. Widget movements don't affect rendered output

2.2 CANVAS_WIDGET.PY - THE RENDERING MISMATCH
----------------------------------------------
Location: editor/src/components/canvas_widget.py
Status: ❌ BROKEN - Rendering loop uses old format

Problem Location:
- Line 417: Main rendering loop in _render_coa_impl()
  ```python
  pos_x = layer.get('pos_x', 0.5)
  pos_y = layer.get('pos_y', 0.5)
  ```
  
Impact:
- Renders nothing when pos_x/pos_y are None
- Should iterate instances and render each
- Current: 1 render per layer
- Expected: N renders per layer (one per instance)

Why This Causes Issues:
- property_sidebar updates instances → render doesn't see changes
- Transform widget updates old format → render might see changes
- Inconsistent: sometimes renders, sometimes doesn't
- Depends on whether migration has run

2.3 CLIPBOARD_ACTIONS.PY - PASTE OFFSET BUG
--------------------------------------------
Location: editor/src/actions/clipboard_actions.py
Status: ❌ BROKEN - Applies offset to old format

Problem Locations:
1. Lines 130-131: paste_layer()
   ```python
   layer['pos_x'] = layer.get('pos_x', 0.5) + offset
   layer['pos_y'] = layer.get('pos_y', 0.5) + offset
   ```

2. Lines 232-233: paste_layer_smart()
   ```python
   layer['pos_x'] = layer.get('pos_x', 0.5) + offset_x
   layer['pos_y'] = layer.get('pos_y', 0.5) + offset_y
   ```

Why This Fails:
- Paste from file: Layers have instances (migration runs)
- Offset applied to layer['pos_x'] (not instances)
- Paste appears at original position, offset ignored
- Creates old format fields on migrated layers

2.4 MAIN.PY - ROTATION SHORTCUT BUG
------------------------------------
Location: editor/src/main.py
Status: ❌ BROKEN - Keyboard rotation uses old format

Problem Location:
- Line 1053: _rotate_selected_layers()
  ```python
  layer['rotation'] = (layer['rotation'] + angle_delta) % 360
  ```

Why This Fails:
- Left/Right arrows trigger rotation
- Updates layer['rotation'] (old format)
- Instances not updated
- Rotation doesn't render
- Property panel might show wrong value

Interesting Note:
- main.py has 11 calls to update_transform_widget_for_layer()
- All at appropriate points (layer selection, duplication, etc.)
- Integration is correct, just uses wrong data format

================================================================================
PART 3: HISTORICAL CONTEXT (Git Archaeology Findings)
================================================================================

3.1 DEVELOPMENT PATTERNS
-------------------------
From HISTORICAL_ANALYSIS.txt analysis of 174 commits:

Commit Pattern Analysis:
- 45% of commits are fixes (79 out of 174)
- 40% related to coordinate/transform issues
- Average time between commits: 12 minutes
- AABB caching: 8 commits over 3 days to stabilize
- Coordinate system: 6+ commits to resolve mismatches

Common Bug Patterns:
1. Coordinate space confusion (layer vs NDC vs pixels)
2. AABB calculation errors (inflation, negative dimensions)
3. Cache invalidation issues
4. Drag state management complexity
5. Multi-selection edge cases

Key Lessons:
- Quick incremental fixes led to patch accumulation
- Coordinate conversions are error-prone
- Three caches (_drag_start_layers, _drag_start_aabb, cached_aabb) are complex
- Transform widget has high coupling to canvas_area
- Defensive programming often missing

3.2 THE FERRIS WHEEL PATTERN
-----------------------------
From commit analysis: Multi-rotation implemented as "ferris wheel"
- Lines 288-312 in canvas_area.py
- Rotates layers around AABB center
- Complex trigonometry for layer repositioning
- One of the more stable features (fewer fixes)

Why It's Stable:
- Clear geometric model
- Well-commented
- Single responsibility
- Defensive checks

What This Teaches Us:
- Clear patterns resist bugs better than quick fixes
- Comments help maintain code
- Geometric operations benefit from visualization

3.3 THE PROPERTY_SIDEBAR SUCCESS STORY
---------------------------------------
property_sidebar.py shows best practices:
- Centralized update method (_update_layer_property)
- Auto-migration on every access
- Defensive programming (bounds checks)
- Clear data flow (data → canvas → widget)

This wasn't always the case. Git history shows it evolved:
- Early: Direct property access
- Middle: Some helper methods
- Current: Fully centralized with migration

Lesson: Refactoring to patterns improves stability

================================================================================
PART 4: THE INTEGRATION PROBLEM (Root Cause Analysis)
================================================================================

4.1 CORE ISSUE: DATA MODEL MISMATCH
------------------------------------

OLD FORMAT (Pre-Phase 2):
```python
layer = {
    'pos_x': 0.5,
    'pos_y': 0.5,
    'scale_x': 1.0,
    'scale_y': 1.0,
    'rotation': 0,
    'depth': 0.0,
    # ... other properties
}
```

NEW FORMAT (Phase 2 - Multi-Instance):
```python
layer = {
    'instances': [
        {
            'pos_x': 0.5,
            'pos_y': 0.5,
            'scale_x': 1.0,
            'scale_y': 1.0,
            'rotation': 0,
            'depth': 0.0
        },
        # ... potentially more instances
    ],
    'selected_instance': 0,  # Index of active instance
    # ... other layer properties (color, texture, mask, flip)
}
```

Phase 2 Goals (from INSTANCE_INTEGRATION_PLAN.txt):
1. ✓ Support multiple instances per layer
2. ✓ Per-instance transform properties
3. ✓ Instance selection mechanism
4. ❌ Transform widget integration (FAILED)
5. ❌ Render multiple instances (PARTIAL)

What Went Wrong:
- Data model changed successfully
- Migration function created successfully
- property_sidebar updated successfully
- canvas_area NOT updated → transform widget broken
- canvas_widget PARTIALLY updated → rendering incomplete
- clipboard/main NOT updated → operations broken

4.2 WHY THE MISMATCH PERSISTS
------------------------------

Technical Reasons:
1. No centralized property access layer
2. Direct dictionary access scattered throughout codebase
3. No type system to enforce format
4. No deprecation warnings for old format
5. Migration is opt-in (must be called explicitly)

Architectural Reasons:
1. canvas_area.py has high complexity (500+ lines)
2. Transform widget tightly coupled to canvas_area
3. No clear abstraction boundary
4. Property access mixed with logic

Development Reasons:
1. Quick incremental development style
2. Phase 2 implemented but not fully integrated
3. Testing focused on visual output (property panel works)
4. Transform widget not tested (visual inspection missed it)

4.3 COUPLING AND COMPLEXITY
----------------------------

canvas_area.py Responsibilities (too many):
- Transform widget lifecycle (create, position, show/hide)
- Coordinate conversions (3 systems: layer, NDC, pixels)
- Drag state management (3 caches)
- Multi-selection logic (AABB calculation)
- Multi-rotation logic (ferris wheel pattern)
- Property updates (writes to layer data)
- Canvas integration (calls canvas_widget methods)

This violates Single Responsibility Principle.

Coupling Diagram:
```
main.py
   ↓ (calls)
canvas_area.update_transform_widget_for_layer()
   ↓ (reads)
layer['pos_x']  ← OLD FORMAT (None/missing)
   ↓ (sets)
transform_widget.set_position()
   ↓ (displays)
[Widget appears at wrong location]

Meanwhile:
property_sidebar._update_layer_property()
   ↓ (writes)
instances[selected_instance]['pos_x']  ← NEW FORMAT
   ↓ (renders)
canvas_widget._render_coa_impl()
   ↓ (reads)
layer.get('pos_x')  ← OLD FORMAT (fallback)
[Rendering works if migration ran]
```

Key Insight: Two parallel update paths exist:
1. property_sidebar → instances → render (WORKS)
2. canvas_area → layer → transform widget (BROKEN)

================================================================================
PART 5: REFACTORING OPPORTUNITIES
================================================================================

5.1 OPTION A: INLINE FIXES (Patch Approach)
--------------------------------------------
Strategy: Update broken files to use instances format

Pros:
- Quick to implement
- Minimal code changes
- Preserves existing architecture

Cons:
- Continues pattern of scattered property access
- No long-term improvement
- High risk of missing edge cases
- Debugging difficulty persists

Estimated Effort: 2-3 hours
Risk Level: MEDIUM
- History shows coordinate fixes often require multiple attempts
- Canvas_area complexity makes changes risky
- Easy to miss edge cases

Files to Change:
1. canvas_area.py (5 locations)
2. canvas_widget.py (1 location)
3. clipboard_actions.py (2 locations)
4. main.py (1 location)

Specific Changes:
```python
# OLD (canvas_area.py line 206):
pos_x = layer.get('pos_x', 0.5)
pos_y = layer.get('pos_y', 0.5)

# NEW:
instances = layer.get('instances', [])
selected_inst = layer.get('selected_instance', 0)
if instances and 0 <= selected_inst < len(instances):
    pos_x = instances[selected_inst].get('pos_x', 0.5)
    pos_y = instances[selected_inst].get('pos_y', 0.5)
else:
    pos_x, pos_y = 0.5, 0.5
```

Risk Assessment:
- AABB calculation (canvas_area lines 233-246): HIGH RISK
  * Iterates all selected layers
  * Calculates bounding box
  * Multiple coordinate conversions
  * Easy to introduce off-by-one errors
  
- Drag state caching (lines 316-325): HIGH RISK
  * Stores initial positions for all layers
  * Must match AABB calculation
  * Cache invalidation is tricky
  
- Multi-rotation (lines 288-312): MEDIUM RISK
  * Complex trigonometry
  * Ferris wheel pattern
  * Well-commented (helps)
  
- Widget positioning (lines 206-215): LOW RISK
  * Single layer, simple access
  * Straightforward change

5.2 OPTION B: REFACTOR TO LAYERACCESSOR (Architectural Fix)
------------------------------------------------------------
Strategy: Create abstraction layer for property access

Design:
```python
class LayerAccessor:
    """Centralized property access with auto-migration"""
    
    INSTANCE_PROPERTIES = ['pos_x', 'pos_y', 'scale_x', 'scale_y', 'rotation', 'depth']
    
    @staticmethod
    def get_property(layer, prop_name):
        """Get property value with auto-migration"""
        if prop_name in LayerAccessor.INSTANCE_PROPERTIES:
            _migrate_layer_to_instances(layer)
            instances = layer.get('instances', [])
            selected_inst = layer.get('selected_instance', 0)
            if 0 <= selected_inst < len(instances):
                return instances[selected_inst].get(prop_name)
        return layer.get(prop_name)
    
    @staticmethod
    def set_property(layer, prop_name, value):
        """Set property value with auto-migration"""
        if prop_name in LayerAccessor.INSTANCE_PROPERTIES:
            _migrate_layer_to_instances(layer)
            instances = layer.get('instances', [])
            selected_inst = layer.get('selected_instance', 0)
            if 0 <= selected_inst < len(instances):
                instances[selected_inst][prop_name] = value
        else:
            layer[prop_name] = value
```

Pros:
- Centralizes migration logic
- Single source of truth
- Future-proof (new properties easy to add)
- Makes codebase more maintainable
- Clear abstraction boundary

Cons:
- Larger code change
- Requires testing all callsites
- Migration effort higher
- Need to locate all property accesses

Estimated Effort: 4-6 hours
Risk Level: LOW-MEDIUM
- More work upfront
- Lower risk of bugs (centralized logic)
- Easier to test (single point of failure)
- Clear migration path

Files to Change:
1. Create: utils/layer_accessor.py (new file)
2. Update: canvas_area.py (replace all property access)
3. Update: canvas_widget.py (replace property access)
4. Update: clipboard_actions.py (replace property access)
5. Update: main.py (replace property access)
6. Consider: property_sidebar.py (could use accessor for consistency)

Migration Strategy:
1. Create LayerAccessor class
2. Add deprecation warnings to direct access
3. Migrate one file at a time
4. Test each migration
5. Remove old format support after full migration

5.3 OPTION C: HYBRID APPROACH (Recommended)
--------------------------------------------
Strategy: Fix critical paths with inline fixes, then refactor

Phase 1: Emergency Inline Fixes (1-2 hours)
- Fix canvas_area.py transform widget positioning (line 206)
- Fix canvas_area.py transform widget changes (line 435)
- Fix main.py rotation shortcut (line 1053)
- Goal: Make transform widget functional

Phase 2: Refactor to LayerAccessor (2-3 hours)
- Create LayerAccessor utility
- Migrate canvas_area.py to use accessor
- Migrate canvas_widget.py to use accessor
- Goal: Prevent future bugs, improve maintainability

Phase 3: Complete Migration (1-2 hours)
- Migrate clipboard_actions.py
- Migrate any remaining files
- Add deprecation warnings
- Goal: Remove old format support entirely

Total Estimated Effort: 4-7 hours
Risk Level: LOW
- Critical fixes first (restore functionality)
- Incremental refactoring (test at each step)
- Clear milestones (can stop after Phase 1 if needed)

Why This Works:
- Immediate fix for user-facing issue
- Long-term improvement for maintenance
- Incremental approach reduces risk
- Each phase independently valuable

================================================================================
PART 6: IMPLEMENTATION CONFIDENCE STRATEGY
================================================================================

6.1 CRITICAL PATH FIXES (Highest Impact, Lowest Risk)
------------------------------------------------------

Fix Priority Matrix:
```
Impact vs Risk:
                HIGH IMPACT              LOW IMPACT
HIGH RISK    | Multi-selection AABB  | Rendering loop     |
             | Drag state caching    | Clipboard paste    |
             |                       |                    |
LOW RISK     | Widget positioning    | Rotation shortcut  |
             | Widget changes        | New layer creation |
```

Start Here (High Impact, Low Risk):
1. canvas_area.py line 206: Widget positioning
2. canvas_area.py line 435: Widget changes
3. main.py line 1053: Rotation shortcut

These three fixes will restore basic transform widget functionality.

6.2 FIX #1: TRANSFORM WIDGET POSITIONING
-----------------------------------------
Location: canvas_area.py, _update_transform_widget_single_selection()
Lines: 206-215
Current Risk: LOW
Impact: HIGH (restores widget visibility)

Current Code (Line 206):
```python
pos_x = layer.get('pos_x', 0.5)
pos_y = layer.get('pos_y', 0.5)
```

Proposed Fix:
```python
# Get position from selected instance
from services.layer_operations import _migrate_layer_to_instances
_migrate_layer_to_instances(layer)

instances = layer.get('instances', [])
selected_inst = layer.get('selected_instance', 0)

if instances and 0 <= selected_inst < len(instances):
    pos_x = instances[selected_inst].get('pos_x', 0.5)
    pos_y = instances[selected_inst].get('pos_y', 0.5)
else:
    # Fallback to defaults if no instances
    pos_x, pos_y = 0.5, 0.5
```

Confidence: 95%
- Pattern proven in property_sidebar.py
- Auto-migration ensures safety
- Defensive checks prevent crashes
- Single-selection case is simplest

Testing:
1. Select layer with instance data
2. Verify widget appears at correct position
3. Move layer via property panel
4. Verify widget follows layer
5. Test with old format layer (migration should work)

Expected Outcome: Widget appears at correct location

6.3 FIX #2: TRANSFORM WIDGET CHANGES
-------------------------------------
Location: canvas_area.py, _on_transform_widget_changed()
Lines: 435-444
Current Risk: LOW
Impact: HIGH (restores widget interaction)

Current Code (Line 435):
```python
layer['pos_x'] = new_pos_x
layer['pos_y'] = new_pos_y
# ... later ...
layer['rotation'] = self.transform_widget.rotation
```

Proposed Fix:
```python
# Update selected instance
from services.layer_operations import _migrate_layer_to_instances
_migrate_layer_to_instances(layer)

instances = layer.get('instances', [])
selected_inst = layer.get('selected_instance', 0)

if instances and 0 <= selected_inst < len(instances):
    instances[selected_inst]['pos_x'] = new_pos_x
    instances[selected_inst]['pos_y'] = new_pos_y
    # ... later ...
    instances[selected_inst]['rotation'] = self.transform_widget.rotation
```

Confidence: 95%
- Mirror of Fix #1
- Same defensive pattern
- Direct property update (no complex calculations)

Testing:
1. Select layer
2. Drag widget handle
3. Verify layer moves in canvas
4. Rotate widget
5. Verify layer rotates in canvas
6. Check property panel updates

Expected Outcome: Widget controls layer position/rotation

6.4 FIX #3: KEYBOARD ROTATION
------------------------------
Location: main.py, _rotate_selected_layers()
Lines: 1053
Current Risk: LOW
Impact: MEDIUM (restores keyboard shortcuts)

Current Code (Line 1053):
```python
layer['rotation'] = (layer['rotation'] + angle_delta) % 360
```

Proposed Fix:
```python
from services.layer_operations import _migrate_layer_to_instances
_migrate_layer_to_instances(layer)

instances = layer.get('instances', [])
selected_inst = layer.get('selected_instance', 0)

if instances and 0 <= selected_inst < len(instances):
    current_rotation = instances[selected_inst].get('rotation', 0)
    instances[selected_inst]['rotation'] = (current_rotation + angle_delta) % 360
```

Confidence: 90%
- Same pattern as Fix #1 and #2
- Slightly lower confidence because main.py context
- Need to verify update_transform_widget_for_layer() propagates correctly

Testing:
1. Select layer
2. Press Left arrow
3. Verify layer rotates counter-clockwise
4. Press Right arrow
5. Verify layer rotates clockwise
6. Check property panel shows updated rotation

Expected Outcome: Arrow keys rotate selected layer

6.5 TESTING STRATEGY
--------------------

Test Scenarios:
1. Fresh layer (created by add emblem button)
2. Loaded layer (from file with instances)
3. Old format layer (manually created, no instances)
4. Migrated layer (old format converted by migration)

For Each Scenario:
- Select layer → widget appears?
- Drag widget → layer moves?
- Rotate widget → layer rotates?
- Press arrow keys → layer rotates?
- Edit property panel → widget updates?

Success Criteria:
- All 5 checks pass for all 4 scenarios
- No console errors
- No visual glitches
- Property panel stays synchronized

Regression Checks:
- Multi-selection AABB (should still be broken, that's OK)
- Ferris wheel rotation (should still work)
- Layer duplication (should work via duplicate_layer())
- Save/load (should work via file_operations.py)

6.6 RISK MITIGATION
-------------------

What Could Go Wrong:
1. Migration function fails
   - Mitigation: _migrate_layer_to_instances is proven, used in multiple places
   - Fallback: Catch exceptions, log errors, use defaults

2. Bounds check fails
   - Mitigation: Defensive checks on instances array and index
   - Fallback: Use default position if out of bounds

3. Property panel doesn't update
   - Mitigation: Test bidirectional sync (widget ↔ panel)
   - Fallback: May need to add explicit panel refresh call

4. Canvas doesn't redraw
   - Mitigation: Existing set_layers() call should trigger redraw
   - Fallback: Add explicit repaint() call if needed

5. Undo/redo breaks
   - Mitigation: _save_state() calls happen AFTER our changes
   - Fallback: May need to verify state capture includes instances

Emergency Rollback Plan:
- Changes are localized to 3 functions
- Can revert individual fixes independently
- Original code preserved in git
- No database or persistent state changes

================================================================================
PART 7: DEFERRED ISSUES (To Address After Critical Fixes)
================================================================================

7.1 MULTI-SELECTION AABB CALCULATION
-------------------------------------
Location: canvas_area.py lines 233-246
Risk: HIGH
Complexity: MEDIUM

Why Deferring:
- Complex calculation with multiple coordinate conversions
- Requires iteration over all selected layers
- AABB caching adds complexity
- Not essential for basic transform widget functionality

Future Fix Strategy:
- Apply same instance access pattern
- Update _init_drag_with_multi_selection() (line 316) simultaneously
- Test with 2, 3, 5, 10 selected layers
- Verify AABB inflation logic still works

7.2 CANVAS RENDERING LOOP
--------------------------
Location: canvas_widget.py line 417
Risk: MEDIUM
Complexity: MEDIUM

Why Deferring:
- Currently works due to migration in file_operations.py
- Doesn't render multiple instances per layer yet
- Future feature (true multi-instance rendering)

Future Fix Strategy:
- Change from single render per layer to loop over instances
- Update depth calculation for instance rendering
- Test with layers that have 2+ instances

7.3 CLIPBOARD PASTE OFFSET
---------------------------
Location: clipboard_actions.py lines 130-131, 232-233
Risk: LOW
Complexity: LOW

Why Deferring:
- Affects paste operation only
- Workaround: paste, then move manually
- Not blocking transform widget

Future Fix Strategy:
- Apply offset to instances[0] instead of layer
- Consider: should offset apply to all instances or just selected?

================================================================================
PART 8: SUCCESS METRICS AND VALIDATION
================================================================================

8.1 DEFINITION OF SUCCESS
--------------------------

Phase 1 Success (Critical Fixes):
✓ Transform widget appears at correct layer position
✓ Dragging widget moves layer in canvas
✓ Rotating widget rotates layer in canvas
✓ Property panel stays synchronized with widget
✓ Arrow keys rotate layer
✓ No regressions in other features

Phase 2 Success (LayerAccessor Refactor):
✓ All property access goes through LayerAccessor
✓ No direct layer['pos_x'] access in codebase
✓ Deprecation warnings in place
✓ Code is more maintainable

Phase 3 Success (Complete Migration):
✓ Old format completely removed
✓ All operations use instances
✓ Tests pass
✓ Documentation updated

8.2 VALIDATION CHECKLIST
-------------------------

Before Making Changes:
[ ] Read all three proposed fixes completely
[ ] Understand the pattern from property_sidebar.py
[ ] Review _migrate_layer_to_instances() implementation
[ ] Back up current working directory
[ ] Create git branch for changes

During Implementation:
[ ] Implement Fix #1 (widget positioning)
[ ] Test Fix #1 with all 4 scenarios
[ ] Implement Fix #2 (widget changes)
[ ] Test Fix #2 with all 4 scenarios
[ ] Implement Fix #3 (keyboard rotation)
[ ] Test Fix #3 with all 4 scenarios

After Implementation:
[ ] Run full test suite (manual, no automated tests exist)
[ ] Test all scenarios documented in section 6.5
[ ] Check for console errors
[ ] Verify no regressions in layer duplication
[ ] Verify save/load still works
[ ] Test undo/redo with transform operations
[ ] Update INSTANCE_INTEGRATION_PLAN.txt with results

8.3 EXPECTED TIMELINE
----------------------

Critical Fixes (Phase 1):
- Reading this document: 30 minutes
- Implementing Fix #1: 15 minutes
- Testing Fix #1: 10 minutes
- Implementing Fix #2: 15 minutes
- Testing Fix #2: 10 minutes
- Implementing Fix #3: 10 minutes
- Testing Fix #3: 10 minutes
- Regression testing: 20 minutes
- Documentation: 10 minutes
Total: ~2 hours

LayerAccessor Refactor (Phase 2):
- Design LayerAccessor: 20 minutes
- Implement LayerAccessor: 30 minutes
- Migrate canvas_area.py: 45 minutes
- Test canvas_area.py: 20 minutes
- Migrate canvas_widget.py: 30 minutes
- Test canvas_widget.py: 15 minutes
- Documentation: 10 minutes
Total: ~2.5 hours

Complete Migration (Phase 3):
- Migrate remaining files: 1 hour
- Add deprecation warnings: 20 minutes
- Full regression testing: 30 minutes
- Documentation: 20 minutes
Total: ~2 hours

Grand Total: ~6.5 hours (worst case)

Realistic: Phase 1 will likely take 1.5-2 hours including testing

================================================================================
PART 9: CONFIDENCE ASSESSMENT
================================================================================

9.1 CONFIDENCE LEVELS
----------------------

Critical Fixes (Phase 1):
Confidence: 90%

Reasoning:
✓ Pattern proven in property_sidebar.py (working for months)
✓ Migration function battle-tested (_migrate_layer_to_instances)
✓ Defensive programming prevents crashes
✓ Changes are localized (3 functions, 3 files)
✓ Clear testing strategy
✓ Low risk of regressions

Concerns:
- Haven't tested multi-selection yet (but that's deferred)
- AABB calculation might be affected (but that's deferred)
- Edge cases might exist (but defensive checks will catch them)

Why Not 100%:
- Software is never 100% certain
- Coordinate systems are historically tricky in this codebase
- Testing is manual (no automated test suite)

LayerAccessor Refactor (Phase 2):
Confidence: 85%

Reasoning:
✓ Clean architectural pattern
✓ Centralized logic is easier to maintain
✓ Property access pattern is well-understood
✓ Similar to successful property_sidebar.py approach

Concerns:
- Larger code change (more places to break)
- Need to find all property access callsites
- May miss some edge cases initially

Why Lower Than Phase 1:
- More moving parts
- Requires changing multiple files simultaneously
- Testing surface is larger

Complete Migration (Phase 3):
Confidence: 80%

Reasoning:
✓ Clear end goal (remove old format)
✓ Deprecation warnings will catch stragglers
✓ Incremental approach reduces risk

Concerns:
- May find unexpected old format usage
- Clipboard/paste operations are less tested
- User-facing edge cases harder to predict

9.2 GO/NO-GO DECISION CRITERIA
-------------------------------

GO (Proceed with Critical Fixes):
✓ Pattern is proven (property_sidebar.py)
✓ Risk is acceptable (localized changes)
✓ Testing strategy is clear
✓ Rollback plan exists
✓ Expected timeline is reasonable

NO-GO (Do Not Proceed):
✗ If property_sidebar.py pattern doesn't actually work
✗ If migration function has bugs
✗ If testing reveals fundamental flaw
✗ If timeline is critical and 2 hours is unacceptable

Current Status: GO
- All GO criteria met
- No NO-GO criteria present
- Ready to proceed with Phase 1

9.3 FINAL RECOMMENDATION
-------------------------

Proceed with HYBRID APPROACH (Option C):
1. Implement Critical Fixes (Phase 1) IMMEDIATELY
   - Restores transform widget functionality
   - Low risk, high impact
   - ~2 hours effort
   
2. Consider LayerAccessor Refactor (Phase 2) NEXT SESSION
   - Improves long-term maintainability
   - Medium risk, high value
   - ~2.5 hours effort
   
3. Defer Complete Migration (Phase 3) UNTIL LATER
   - Nice-to-have, not critical
   - Can be done incrementally over time
   - ~2 hours effort

Why This Order:
- User-facing issue resolved quickly (transform widget works)
- Foundation improved (LayerAccessor provides structure)
- Perfectionism deferred (complete migration can wait)
- Each phase independently valuable (can stop after any phase)

================================================================================
PART 10: ACTIONABLE NEXT STEPS
================================================================================

IMMEDIATE ACTIONS:
1. Read this document completely (you're doing this now)
2. Review property_sidebar.py lines 1167-1204 (working pattern)
3. Review layer_operations.py lines 102-130 (migration function)
4. Create git branch: "fix/transform-widget-instances"
5. Begin Fix #1: canvas_area.py line 206

DETAILED STEPS FOR FIX #1:
```python
# File: editor/src/components/canvas_area.py
# Function: _update_transform_widget_single_selection
# Lines: 206-215

# BEFORE (current broken code):
pos_x = layer.get('pos_x', 0.5)
pos_y = layer.get('pos_y', 0.5)

# AFTER (fixed code):
# Get position from selected instance
from services.layer_operations import _migrate_layer_to_instances
_migrate_layer_to_instances(layer)

instances = layer.get('instances', [])
selected_inst = layer.get('selected_instance', 0)

if instances and 0 <= selected_inst < len(instances):
    pos_x = instances[selected_inst].get('pos_x', 0.5)
    pos_y = instances[selected_inst].get('pos_y', 0.5)
else:
    # Fallback to defaults if no instances
    pos_x, pos_y = 0.5, 0.5
```

Test Fix #1:
1. Run editor
2. Add emblem layer
3. Select layer
4. Verify widget appears at correct position
5. Move layer via property panel sliders
6. Verify widget follows layer position

If Fix #1 Succeeds:
- Proceed to Fix #2 (same file, line 435)
- Pattern is the same, just writing instead of reading

STOPPING POINTS:
- After Fix #1: Widget positioning works, but dragging doesn't update layer
- After Fix #2: Widget fully functional for drag/rotate
- After Fix #3: Keyboard shortcuts work

DOCUMENTATION UPDATES:
- Update INSTANCE_INTEGRATION_PLAN.txt with results
- Note which fixes were applied
- Document any issues encountered
- Update confidence assessment based on results

================================================================================
END OF CONFIDENCE DOCUMENT
================================================================================

Status: READY TO PROCEED
Confidence: 90%
Estimated Time: 2 hours for Phase 1
Risk Level: LOW
Expected Outcome: Transform widget fully functional

The path forward is clear. The patterns are proven. The risks are managed.
Time to fix the transform widget.
