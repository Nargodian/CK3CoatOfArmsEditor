TRANSFORM WIDGET COORDINATE MATHEMATICS AUDIT
==============================================
Date: February 4, 2026

COORDINATE SPACES INVOLVED
--------------------------
1. CoA Space: 0.0 to 1.0 (normalized), origin at (0.5, 0.5)
2. Frame Space: ~0.0 to 1.0 (with frame scaling), origin at (0.5, 0.5)
3. Canvas Top-Left: 0 to width/height pixels, origin at (0, 0) top-left
4. Canvas Center-Origin: -width/2 to +width/2 pixels, origin at (width/2, height/2)


PATH 1: MODEL → TRANSFORM WIDGET (Display)
===========================================
File: canvas_area.py, method _on_selection_changed()
Lines: 477-502 (single instance case)

STEP 1: Read from CoA model (CoA space 0-1)
--------------------------------------------
Code (line 480-484):
    pos_x = self.main_window.coa.get_layer_pos_x(uuid)      # 0-1 range
    pos_y = self.main_window.coa.get_layer_pos_y(uuid)      # 0-1 range
    scale_x = self.main_window.coa.get_layer_scale_x(uuid)  # 1.0 = normal
    scale_y = self.main_window.coa.get_layer_scale_y(uuid)  # 1.0 = normal
    rotation = self.main_window.coa.get_layer_rotation(uuid) # degrees

Example: pos_x=0.5, pos_y=0.5 (center of CoA)


STEP 2: Convert CoA → Canvas pixels (top-left origin)
------------------------------------------------------
Code (line 491-492):
    center_x_topleft, center_y_topleft = self.canvas_widget.coa_to_canvas(pos_x, pos_y)
    half_w, half_h = self.canvas_widget.coa_scale_to_pixels(scale_x, scale_y)

Method: canvas_widget.coa_to_canvas(pos_x, pos_y)
    → Calls coa_to_frame(pos_x, pos_y)
    → Then frame_to_canvas(frame_x, frame_y)

coa_to_frame (canvas_coordinate_mixin.py lines 29-58):
    frame_scale, frame_offset = self.get_frame_transform()
    
    centered_x = pos_x - 0.5                    # Move to origin
    centered_y = pos_y - 0.5
    
    scaled_x = centered_x * frame_scale[0]      # Apply frame scale
    scaled_y = centered_y * frame_scale[1]
    
    uncentered_x = scaled_x + 0.5               # Move back from origin
    uncentered_y = scaled_y + 0.5
    
    frame_x = uncentered_x - frame_offset[0] * frame_scale[0]  # Apply offset
    frame_y = uncentered_y - frame_offset[1] * frame_scale[1]
    
    return frame_x, frame_y

Example: pos_x=0.5, frame_scale=(1.0, 1.0), frame_offset=(0, 0)
    centered_x = 0.5 - 0.5 = 0.0
    scaled_x = 0.0 * 1.0 = 0.0
    uncentered_x = 0.0 + 0.5 = 0.5
    frame_x = 0.5 - 0 = 0.5

frame_to_canvas (canvas_coordinate_mixin.py lines 95-149):
    width = self.width()
    height = self.height()
    canvas_size = min(width, height)
    
    # Frame (0-1) → GL (-1 to 1)
    gl_x = frame_x * 2.0 - 1.0
    gl_y = -(frame_y * 2.0 - 1.0)  # Flip Y
    
    # Apply zoom
    gl_x = gl_x / zoom_level
    gl_y = gl_y / zoom_level
    
    # GL → pixels
    pixel_x = gl_x * (canvas_size / 2)
    pixel_y = -gl_y * (canvas_size / 2)
    
    # Add pan and center
    x = width/2 + pixel_x + pan_x
    y = height/2 + pixel_y + pan_y
    
    return x, y

Example: frame_x=0.5, width=800, height=800, zoom=1.0, pan=(0,0)
    canvas_size = 800
    gl_x = 0.5 * 2.0 - 1.0 = 0.0
    gl_y = -(0.5 * 2.0 - 1.0) = 0.0
    pixel_x = 0.0 * 400 = 0.0
    pixel_y = 0.0 * 400 = 0.0
    x = 400 + 0 + 0 = 400
    y = 400 + 0 + 0 = 400

RESULT: center_x_topleft=400, center_y_topleft=400 (center of canvas widget)


STEP 3: Convert Canvas top-left → Center-origin
------------------------------------------------
Code (line 495-496):
    center_x = center_x_topleft - self.transform_widget.width() / 2
    center_y = center_y_topleft - self.transform_widget.height() / 2

CRITICAL ASSUMPTION: transform_widget.width() == canvas_widget.width()

Example: center_x_topleft=400, transform_widget.width()=800
    center_x = 400 - 800/2 = 400 - 400 = 0
    center_y = 400 - 800/2 = 400 - 400 = 0

RESULT: center_x=0, center_y=0 (center in widget's center-origin space)


STEP 4: Set transform widget position
--------------------------------------
Code (line 499):
    self.transform_widget.set_transform(center_x, center_y, half_w, half_h, rotation, is_multi_selection=False)

Widget stores: center_x=0, center_y=0, half_w, half_h, rotation


STEP 5: Paint transform widget
-------------------------------
File: transform_widget.py, method paintEvent() (lines 172-191)

Code (line 188):
    painter.translate(self.width() / 2, self.height() / 2)

This translates the painter's origin to the center of the transform_widget.

Then for each handle (line 191):
    handle.draw(painter, self.center_x, self.center_y, self.half_w, self.half_h, self.rotation)

Example: Bbox corners handle (transform_widgets/bbox_mode.py):
    def draw(self, painter, center_x, center_y, half_w, half_h, rotation):
        # Draw rectangle at (center_x ± half_w, center_y ± half_h)
        
With center_x=0, center_y=0, this draws the bbox centered at the painter's origin,
which is at the center of the widget (due to translate).

VISUAL RESULT: Bbox appears centered on canvas ✓



PATH 2: TRANSFORM WIDGET → MODEL (User Drag)
=============================================
File: canvas_area.py, method _on_transform_changed()
Lines: 560-620

STEP 1: Receive center-origin coordinates from widget
------------------------------------------------------
Code (line 560):
    def _on_transform_changed(self, center_x, center_y, half_w, half_h, rotation):

Widget sends: center_x, center_y in center-origin pixel space
Example: User drags bbox 50 pixels right from center
    center_x = 50, center_y = 0


STEP 2: Convert Center-origin → Canvas top-left
------------------------------------------------
Code (line 572-573):
    center_x_topleft = center_x + self.transform_widget.width() / 2
    center_y_topleft = center_y + self.transform_widget.height() / 2

Example: center_x=50, transform_widget.width()=800
    center_x_topleft = 50 + 800/2 = 50 + 400 = 450
    center_y_topleft = 0 + 800/2 = 400

RESULT: center_x_topleft=450, center_y_topleft=400 (canvas top-left pixels)


STEP 3: Convert Canvas pixels → CoA space
------------------------------------------
Code (line 576-577):
    pos_x, pos_y = self.canvas_widget.canvas_to_coa(center_x_topleft, center_y_topleft)
    scale_x, scale_y = self.canvas_widget.pixels_to_coa_scale(half_w, half_h)

Method: canvas_widget.canvas_to_coa(x, y)
    → Calls canvas_to_frame(x, y)
    → Then frame_to_coa(frame_x, frame_y)

canvas_to_frame (canvas_coordinate_mixin.py lines 98-149):
    width = self.width()
    height = self.height()
    canvas_size = min(width, height)
    
    # Remove pan and centering
    pixel_x = x - width/2 - pan_x
    pixel_y = y - height/2 - pan_y
    
    # Pixels → GL
    gl_x = pixel_x / (canvas_size / 2)
    gl_y = -pixel_y / (canvas_size / 2)
    
    # Remove zoom
    gl_x = gl_x / zoom_level
    gl_y = gl_y / zoom_level
    
    # GL → frame
    frame_x = (gl_x + 1.0) / 2.0
    frame_y = (-gl_y + 1.0) / 2.0
    
    return frame_x, frame_y

Example: x=450, y=400, width=800, height=800, zoom=1.0, pan=(0,0)
    canvas_size = 800
    pixel_x = 450 - 400 - 0 = 50
    pixel_y = 400 - 400 - 0 = 0
    gl_x = 50 / 400 = 0.125
    gl_y = -0 / 400 = 0.0
    frame_x = (0.125 + 1.0) / 2.0 = 0.5625
    frame_y = (0.0 + 1.0) / 2.0 = 0.5

frame_to_coa (canvas_coordinate_mixin.py lines 61-90):
    frame_scale, frame_offset = self.get_frame_transform()
    
    # Remove frame offset
    no_offset_x = frame_x + frame_offset[0] * frame_scale[0]
    no_offset_y = frame_y + frame_offset[1] * frame_scale[1]
    
    # Center position
    centered_x = no_offset_x - 0.5
    centered_y = no_offset_y - 0.5
    
    # Remove frame scale
    unscaled_x = centered_x / frame_scale[0]
    unscaled_y = centered_y / frame_scale[1]
    
    # Move back from origin
    pos_x = unscaled_x + 0.5
    pos_y = unscaled_y + 0.5
    
    return pos_x, pos_y

Example: frame_x=0.5625, frame_scale=(1.0, 1.0), frame_offset=(0, 0)
    no_offset_x = 0.5625 + 0 = 0.5625
    centered_x = 0.5625 - 0.5 = 0.0625
    unscaled_x = 0.0625 / 1.0 = 0.0625
    pos_x = 0.0625 + 0.5 = 0.5625

RESULT: pos_x=0.5625, pos_y=0.5 (CoA space)


STEP 4: Write to CoA model
---------------------------
Code (lines 600-650, various paths):
For single instance:
    self.main_window.coa.set_layer_pos_x(uuid, pos_x)
    self.main_window.coa.set_layer_pos_y(uuid, pos_y)


MATHEMATICAL VERIFICATION
==========================

Forward Path (Model → Widget):
-------------------------------
CoA space: pos_x=0.5 (center)
    ↓ coa_to_frame: frame_x=0.5
    ↓ frame_to_canvas: x=400 (top-left pixels)
    ↓ topleft→center: center_x = 400 - 400 = 0
Widget displays at: center_x=0 (center of widget) ✓

Reverse Path (Widget → Model):
-------------------------------
Widget position: center_x=50 (50px right of center)
    ↓ center→topleft: x = 50 + 400 = 450 (top-left pixels)
    ↓ canvas_to_frame: frame_x=0.5625
    ↓ frame_to_coa: pos_x=0.5625
Model stores: pos_x=0.5625 ✓

Round-trip Test:
----------------
Start: pos_x=0.5
    → Forward: center_x=0
    → User drags 50px right: center_x=50
    → Reverse: pos_x=0.5625
    → Forward again: center_x=50
CONSISTENT ✓


CRITICAL DEPENDENCIES
======================

1. DIMENSION MATCHING
   Lines 495-496, 572-573 assume:
       transform_widget.width() == canvas_widget.width()
       transform_widget.height() == canvas_widget.height()
   
   Verified by:
   - transform_widget.py line 74: setGeometry(0, 0, parent.width(), parent.height())
   - transform_widget.py line 80: eventFilter resizes on parent resize
   - canvas_area.py line 61-64: canvas_widget fills container with stretch=1
   - transform_widget parented to canvas_container (same parent as canvas_widget)
   
   ASSUMPTION VALID ✓

2. COORDINATE ORIGIN CONSISTENCY
   - coa_to_canvas returns top-left origin pixels (0,0 at widget top-left)
   - Transform widget painter translates to center (width/2, height/2)
   - Conversions subtract/add width/2, height/2 consistently
   
   CONSISTENT ✓

3. FRAME TRANSFORM SYMMETRY
   - coa_to_frame and frame_to_coa are mathematical inverses
   - Both use same get_frame_transform() call
   
   SYMMETRIC ✓


POTENTIAL ISSUES TO INVESTIGATE
================================

Issue 1: Widget dimension mismatch at startup
----------------------------------------------
HYPOTHESIS: On first paint, transform_widget might not have correct dimensions yet
LOCATION: transform_widget.py line 74 (setGeometry in __init__)
TEST: Add logging to verify dimensions match:
    print(f"Transform: {self.transform_widget.width()}x{self.transform_widget.height()}")
    print(f"Canvas:    {self.canvas_widget.width()}x{self.canvas_widget.height()}")

Issue 2: Resize event timing
-----------------------------
HYPOTHESIS: During resize, transform_widget updates after canvas_widget
LOCATION: transform_widget.py line 80 (eventFilter for Resize)
RISK: Brief moment where dimensions don't match
FIX: Force synchronization in _on_selection_changed

Issue 3: Canvas container size vs canvas widget size
-----------------------------------------------------
HYPOTHESIS: Container might have different size than canvas_widget
LOCATION: canvas_area.py line 55-64 (canvas_container setup)
NOTE: Container has margins=0, spacing=0, canvas stretch=1
SHOULD BE: Container size == canvas_widget size
VERIFY: Check if preview_bar or bottom_bar affect container height


NEXT STEPS
==========
1. Add dimension logging to _on_selection_changed before conversions ✓ DONE
2. Add dimension logging to _on_transform_changed before conversions ✓ DONE
3. Check actual runtime values when parallax occurs ✓ VERIFIED
4. Verify transform_widget eventFilter is working (resize synchronization) ✓ WORKING

VERIFICATION RESULTS
====================
From terminal output (user dragged emblem):

Dimensions Match:
-----------------
[WIDGET→MODEL] Transform: 800x585, Canvas: 800x585
[PAINT] Widget geometry: pos=(0, 0), size=(800, 585)
[PAINT] Canvas geometry: pos=(0, 0), size=(800, 585)

✓ transform_widget.width() == canvas_widget.width() == 800
✓ transform_widget.height() == canvas_widget.height() == 585
✓ Both widgets at position (0, 0) relative to parent (canvas_container)

Round-trip Perfect:
-------------------
Drag ended at: Center(-41.0, -12.0)
    → TopLeft(359.0, 280.5)
    → CoA(0.430, 0.479)

Selection changed (read from model):
    CoA(0.430, 0.479)
    → TopLeft(359.0, 280.5)
    → Center(-41.0, -12.0)

✓ Round-trip is EXACT - no mathematical error

CONCLUSION: The mathematics are PERFECT. Dimensions match. Round-trip works.

So why does the user still see parallax?


HYPOTHESIS: Visual vs Logical Mismatch
=======================================

The transform widget is painting correctly RELATIVE TO ITSELF, but the canvas
is rendering the emblem at a DIFFERENT location. The issue is NOT in the 
coordinate conversions for the transform widget - those are perfect.

The issue must be in HOW THE CANVAS RENDERS THE EMBLEM.

Potential causes:
1. Canvas rendering uses different coordinate calculations than coa_to_canvas
2. Canvas has a viewport offset that isn't accounted for
3. Frame transform applied differently in rendering vs coordinate conversion
4. Zoom/pan applied differently in rendering vs coordinate math

NEXT INVESTIGATION:
-------------------
Compare the canvas RENDERING code to the coordinate conversion code:
- Where does canvas read layer position to render?
- What transformations does it apply?
- Does it match coa_to_canvas exactly?
